[{"content":"","permalink":"https://train0405.github.io/posts/blog/blog/","summary":"","title":"Blog"},{"content":"","permalink":"https://train0405.github.io/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://train0405.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"","permalink":"https://train0405.github.io/posts/tech/tech/","summary":"","title":"Tech"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"https://train0405.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"关于我\n英文名: Train 职业: 程序员 运动: 跑步、乒乓球、爬山 ","permalink":"https://train0405.github.io/about/","summary":"关于我 英文名: Train 职业: 程序员 运动: 跑步、乒乓球、爬山","title":"🙋🏻‍♂️关于"},{"content":" mysql笔记 SQL 语句分类 DQL（数据查询语言）：查询语句，凡是select语句都是DQL\nDML（数据操作语言）：insert delete update，对表中的数据进行增删改\nDDL（数据定义语言）：create drop alter，对表结构的增删改\nTCL（事务控制语言）：commit提交事务，rollback回滚事务。（T：transaction）\nDCL（数据控制语言）：grant授权、revoke撤销权限等。\n命令 创建数据库 使用数据库 显示表 删除数据库 查看表结构 查看mysql版本 查看表创建时的语句\n1 2 3 4 5 6 7 create database mydb use mydb show tables drop database mydb desc table_name select version() show create table table_name 查询语句 语法格式\n1 select 字段1,字段2,... from table_name; 给查询字段起别名\n1 select EMPNO AS \u0026#39;编号\u0026#39;,ENAME as \u0026#39;姓名\u0026#39; from emp; 给查询字段做运算\n1 select EMPNO AS \u0026#39;编号\u0026#39;,ENAME as \u0026#39;姓名\u0026#39;,sal*12 as \u0026#39;年薪\u0026#39; from emp; 查询所有(实际开发中，效率低，不使用)\n1 select * from emp 条件查询 语法格式 查询字符串类型字段需要加上单引号\n1 2 3 4 5 6 select 字段,字段... from table_name where 条件;\t找出大于3000的工资的员工 大于等于 \u0026gt;= 不等于\u0026lt;\u0026gt; 小于\u0026lt;\n1 2 3 4 5 6 select * from emp where sal \u0026gt; 3000; 查询工资大于等于1000 小于等于3000 BETWEEN\u0026hellip;AND\u0026hellip;. 两个值之间 闭区间[1000,3000]\n1 2 3 4 5 6 select * from emp where sal BETWEEN 1000 AND 3000; 运算符 说明 and 并且 or 或者 in 包含 相当于多个or not not 可以取非，主要用在 is 或者 in 中 （where id not in (1,2,3)） like 模糊查询 is null 为 null(is not null 不为空) 找出工作岗位时 MANAGER和SALESMAN的员工\n1 2 3 4 5 6 7 8 9 10 11 12 13 select * from emp where JOB in (\u0026#39;SALESMAN\u0026#39;,\u0026#39;MANAGER\u0026#39;); # OR select * from emp where JOB= \u0026#39;SALESMAN\u0026#39;OR JOB=\u0026#39;MANAGER\u0026#39;; and 和 or 联合起来用 ：找出薪资大于2000的，并且部门编号是20 或者 30 的员工\n1 2 3 4 5 6 7 8 9 10 11 12 13 select * from emp where sal \u0026gt; 2000 and DEPTNO in(20,30); # OR select * from emp where sal \u0026gt; 2000 and ( DEPTNO= 20 or DEPTNO=30); 错误写法:\n1 2 3 4 5 6 select * from emp where sal \u0026gt; 2000 and DEPTNO= 20 or DEPTNO=30; 错误分析：and和or放在一起是，and先执行。 sal \u0026gt; 2000 and DEPTNO= 20 先执行，然后再把 or DEPTNO=30的员工查出来。and 优先级高，与前后顺序无关。\n当优先级不确定的时候加小括号()。优先执行。\n模糊查询 %:代表任意多个字符\n_:代表任意一个字符\n找出名字中含有O的\n1 2 3 4 5 6 select * from emp where ENAME like \u0026#39;%o%\u0026#39;; 排序 order by默认升序 asc 升序 desc降序 order by是最后执行的\n1 2 3 4 5 select * from emp order by sal 分组函数 记住：所有的分组函数都是对 “一组”数据进行操作\n分组函数也叫聚合函数，多行处理函数，意思就是输入多行，输出一行。分组函数一共5个，没有别的\n1 2 3 4 5 6 7 8 9 10 # 计数 select count(*) from emp; # 求和 select sum(sal) from emp; # 最大值 select max(sal) from emp; # 最小值 select min(sal) from emp; # 平均值 select avg(sal) from emp; 特点：分组函数运算时自动忽略 null，null不参与运算。分组函数不把 null 放在眼里。\n计算每个员工的年薪\n1 select ENAME,(sal+ifnull(comm,0))*12 as \u0026#39;年薪\u0026#39; from emp; 注意事项：和 null 值做运算，结果一定为 null 。ifnull(param1,param2)函数第一个参数为字段，第二个参数为预值。若字段值为 null。\n则用预值处理。\n规则：分组函数不能直接使用在 where 子句当中\ncount(*):统计总数量\ncount(某个字段):统计某个字段不为 null 的总数量\n分组查询group by group by :按照某个字段或者某些字段进行分组。\nhaving ：having 是对分组之后的数据进行再次过滤。\n找出每个岗位的最高薪资\n1 2 3 4 5 6 7 # where先执行，然后执行进行group by分组，然后 select 每一组的最大工资。执行顺序 先 from 再group by 再select max() # 分组函数永远都是在group by执行后再执行。 # 当sql语句没有 group by 的时候，整张表的数据自成一组。 # 分组函数必须在分完组后才能用 # 分组函数不能放在 where 后面 。是因为在where max(字段) 的时候 group by 还没有执行 select job ,max(sal) from emp group by job 执行顺序\n1 2 3 4 5 6 7 8 9 10 11 12 select------5 xx from--------\u0026gt;1 xx where-------\u0026gt;2 xx group by ---\u0026gt;3 xx having -----\u0026gt;4 xx order by ---\u0026gt;6 xx 注意事项：当一条sql语句中有 group by 的话，select 后面只能跟分组函数和参与分组的字段。\n查出每个部门不同工作岗位的最高薪资 ,按照deptno和job分组，相同部门和相同岗位分为一组，找出分组后的最大工资。\n1 select DEPTNO,job ,max(sal)from emp group by DEPTNO,job; 1 2 3 4 5 6 select deptno,count(deptno),avg(sal) from emp group by deptno # COUNT 与分组函数一起使用，count(字段) 会得到组成员的数量 10,3,2916.666667 20,5,2175 30,6,1566.666667 having 如果想对分组数据再进行过滤需要使用having语句。\n找出每个部门的最高薪资，要求显示薪资大于2900的\n效率低\n1 select DEPTNO, max(sal) from emp group by DEPTNO having max(sal) \u0026gt;2900 效率高\n1 SELECT DEPTNO,max(SAL) FROM EMP WHERE SAL \u0026gt;2900 group by DEPTNO; 妙点在于 where 先执行，执行完后在分组。\n找出每个部门的平均薪资，要求显示薪资大于2000的\n1 select DEPTNO,avg(sal) from emp group by DEPTNO having avg(sal) \u0026gt;2000 distinct 去重，只能用在所有字段的前面。当有多个字段在distinct的后面，可以把多个字段值看成一个整体去重。\n1 2 3 4 #查询有哪些上级领导 select distinct MGR from emp #查询岗位数量 distinct去除重复的岗位 SELECT COUNT(DISTINCT (JOB)) FROM EMP; 连接查询 笛卡尔积：当两张表进行查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。\n避免笛卡尔积：加条件过滤。加了条件也不会减少数据库查询匹配记录。\n双表查询原理：A表的第一条记录匹配B表的每一条记录，第二天记录匹配B表的每一条记录。产生笛卡尔积。可以理解为产生一个新的第三张表C，第三张表C，包含表A和表B的所有字段组合(A表8个字段，B表3个字段，那么C表就会产生11个字段，A表8条记录，B表3条记录，不加过滤条件 on 的话，就会产生24条记录。可以把他们组合的表来当成新的表来通过筛选)。\n内连接之等值连接 格式\n1 2 3 4 5 6 7 8 9 10 11 select xx from table_a inner join\ttable_b on 连接条件 where....\t查询每个员工的部门名称。要求显示员工名和部门名 内连接的inner 可以省略\n1 2 3 4 5 6 7 8 select e.ENAME,e.SAL,d.DNAME from emp e inner join dept d on e.DEPTNO = d.DEPTNO 内连接之非等值连接 找出每个员工的工资等级，要求显示员工名、工资、工资等级\n1 2 3 4 5 6 7 8 9 10 select e.ENAME,e.SAL,s.GRADE from emp e inner join salgrade s on e.sal \u0026gt;= s.LOSAL and e.sal \u0026lt;= s.HISAL; 内连接之自连接 自己连接自己，一张表看做两张表\n找出每个员工的上级领导，要求显示员工名和对应的领导名\n1 2 3 4 5 6 7 8 select e1.ename as \u0026#39;员工名\u0026#39; ,e2.ename as \u0026#39;领导\u0026#39; from emp e1 inner join emp e2 on e1.mgr = e2.empno +\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026ndash;+ | 员工名 | 领导 | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026ndash;+ | SMITH | FORD | | ALLEN | BLAKE | | WARD | BLAKE | | JONES | KING | | MARTIN | BLAKE | | BLAKE | KING | | CLARK | KING | | SCOTT | JONES | | TURNER | BLAKE | | ADAMS | SCOTT | | JAMES | BLAKE | | FORD | JONES | | MILLER | CLARK | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026ndash;+ 13 rows in set (0.00 sec)\n注意:king 没有匹配的领导，所以内连接没有查出来，内连接只会查询出匹配条件的数据\n外连接 什么是外连接，和内连接有什么区别？\n内连接：两张表没有主副之分，两张表是平等的。\n​\t假设A表和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录都查询出来。连接结果集只包含，符合连接条件的行。这就是内连接(个人理解：也就是说，A和B产生虚拟的第三张表，只会包含符合连接条件的行记录，A表逐行匹配B表，不符合连接条件的过滤，过滤，符合的放到第三张表上。就是内连接)\n外连接：\n​\t假设A表和B表进行连接，使用外连接的话，AB两张表有一张表是主表，一张表是副表，主要查询主表中的数据，捎带着查询副表，\n当副表中的数据没有和主表中的数据匹配上副表自动模拟出null与之匹配。(左表数据全部显示出来，符合条件的显示匹配副表的行，不符合条件的副表显示null)\n1 2 3 4 select e1.ENAME as \u0026#39;员工\u0026#39;,e2.EMPNO as \u0026#39;领导\u0026#39; from emp e1 left join emp e2 on e1.MGR = e2.EMPNO +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026ndash;+ | 员工 | 领导 | +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026ndash;+ | SMITH | 7902 | | ALLEN | 7698 | | WARD | 7698 | | JONES | 7839 | | MARTIN | 7698 | | BLAKE | 7839 | | CLARK | 7839 | | SCOTT | 7566 | | KING | NULL | | TURNER | 7698 | | ADAMS | 7788 | | JAMES | 7698 | | FORD | 7566 | | MILLER | 7782 | +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026ndash;+\n14 rows in set (0.00 sec)\n注意:king 没有匹配的领导，左外连接会把左表的数据都查出来，符合条件的就显示符合条件的值，不符合的显示null\n内连接 外连接总结\n内连接：只显示满足条件匹配出来的结果，不满足条件的就查询出来\n外连接：逐行匹配，满足条件的行就匹配出来，不满足的右表就显示null.\n找出哪个部门没有员工\n1 2 3 4 5 6 7 8 9 10 11 select d.* from dept d left join emp e on d.DEPTNO = e.DEPTNO where e.DEPTNO is null; 三张表的连接查询 找出每一个员工的部门名称以及工资等级\n1 2 3 4 5 SELECT e.ENAME, d.DNAME, s.GRADE FROM emp e JOIN dept d ON e.deptno = d.deptno join salgrade s on e.SAL between s.LOSAL and s.HISAL; 子查询 什么是子查询？子查询可以出现在哪里？\nselect 语句中嵌套 select 语句，被嵌套的select语句是子查询\n子查询可以出现在哪里\nselect\n​\t..(select)\nfrom\n​\t..(selecct)\nwherer\n​\t..(select)\nwhere 子句中使用子查询 找出高于平薪资的员工信息\n1 select ENAME from emp e WHERE e.sal \u0026gt; (SELECT avg(sal) FROM emp ) from后面嵌套子查询 找出每个部门平均薪水的薪资等级\n1 2 3 SELECT t.deptno,t.avgsal, s.grade FROM (SELECT deptno, AVG(sal) AS \u0026#39;avgsal\u0026#39; FROM emp GROUP BY deptno) t LEFT JOIN salgrade s ON t.avgsal BETWEEN s.losal AND s.hisal; select后面嵌套子查询 通过子查询，找出每个员工所在的部门名称，要求显示员工名和部门名。\n1 select e.ename ,(SELECT d.dname FROM dept d WHERE d.deptno = e.deptno) as dname from emp e UNION MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。\nunion 可以将两张没有关系的表查询结果放在一个结果集合中，in 和 or 关键字不行。\n找出工作岗位是SALESMAN 和MANAGER的员工\n1 2 3 4 5 6 7 8 SELECT e.ename FROM emp e WHERE e.job = \u0026#39;SALESMAN\u0026#39; UNION SELECT e2.ename FROM emp e2 WHERE e2.job = \u0026#39;MANAGER\u0026#39; UNION 只会选取多个表中不同的值。请使用 UNION ALL 来选取重复的值！\n1 2 3 4 5 6 SELECT e.ename FROM emp e UNION SELECT e2.ename FROM emp e2 +\u0026mdash;\u0026mdash;\u0026ndash;+ | ename | +\u0026mdash;\u0026mdash;\u0026ndash;+ | SMITH | | ALLEN | | WARD | | JONES | | MARTIN | | BLAKE | | CLARK | | SCOTT | | KING | | TURNER | | ADAMS | | JAMES | | FORD | | MILLER | +\u0026mdash;\u0026mdash;\u0026ndash;+ 14 rows in set (0.00 sec)\n选取所有的值，包含重复\n1 2 3 4 5 6 SELECT e.ename FROM emp e UNION ALL SELECT e2.ename FROM emp e2 +\u0026mdash;\u0026mdash;\u0026ndash;+ | ename | +\u0026mdash;\u0026mdash;\u0026ndash;+ | SMITH | | ALLEN | | WARD | | JONES | | MARTIN | | BLAKE | | CLARK | | SCOTT | | KING | | TURNER | | ADAMS | | JAMES | | FORD | | MILLER | | SMITH | | ALLEN | | WARD | | JONES | | MARTIN | | BLAKE | | CLARK | | SCOTT | | KING | | TURNER | | ADAMS | | JAMES | | FORD | | MILLER | +\u0026mdash;\u0026mdash;\u0026ndash;+ 28 rows in set (0.00 sec)\nlimit 取结果集中的部分数据。\nlimit startIndex,length\n第一个参数表示取值起始位置，limit 后面的0表示查询结果集中的第一条数据，1表示结果集的第二条数据。\n第二个表示取几个。\n取出工资前5名的员工\n1 SELECT * FROM emp ORDER BY sal DESC LIMIT 0,5 表的创建 建表语句的语法格式：\ncreate table 表名（\n字段名1 数据类型\n字段名2 数据类型\n字段名3 数据类型\n\u0026hellip;.\n）；\n关于MYSQL当中字段的数据类型？以下只说常见的\nint 整数型（java中的int）\nbigint 长整型（Java中的long）\nfloat 浮点型（Java中的float double）\nchar 定长浮点型（string）\nvarchar 可变长字符串（stringbuffer/stringBuilder）\ndata 日期类型（对应java.sql. data类型 ）\nBLOB 二进制大对象（存储图片、视频等流媒体信息）Binary large OBject （对应Java中的object）\nCLOB 字符大对象（存储较大文本，比如，可以存储4G的字符串） Character Large OBject（对应java中的Object）\nchar和varchar怎么选择？\n在实际的开发中，当某个字段中的数据长度不发生改变的时候，是定长的，性别等都是采用char。\n当一个字段的数据长度不确定，例如：简介、姓名等都是采用varchar。\ninsert 语法格式:\n​\tinsert into 表名（字段名1，字段名2，字段名3\u0026hellip;.）values(值1，值2，值3)\n要求：字段的数量和值的数量相同 ，并且数据类型要对应相同 。\n字段名顺序可以调换。但是字段1\u0026ndash;\u0026gt;对应值1，字段2对应\u0026mdash;\u0026gt;值2。字段的下标和值的下标一一对应。\ninsert格式1\n1 INSERT INTO t_student (id, sex, classno, birth,name) VALUES (1,\u0026#39;1\u0026#39;,\u0026#39;高三一班\u0026#39;,\u0026#39;19800901\u0026#39;,\u0026#39;张三\u0026#39;) insert格式2 VALUES的顺序要与表格顺序一致，数量一致。\n1 INSERT INTO t_student VALUES (1,\u0026#39;李四\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;高三一班\u0026#39;,\u0026#39;19801010\u0026#39;) insert格式3 一次插入多行数据\n1 INSERT INTO t_student VALUES (1,\u0026#39;李四\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;高三一班\u0026#39;,\u0026#39;19801010\u0026#39;),(1,\u0026#39;王五\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;高三一班\u0026#39;,\u0026#39;19801010\u0026#39;),(1,\u0026#39;赵六\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;高三一班\u0026#39;,\u0026#39;19801010\u0026#39;) 表的复制 create table tab_name as select 语句; 将查询结果当作复制到一张新表。\n1 create TABLE emp1 as select e.empno,e.ename,e.sal from emp e 修改表的数据 语法格式：\n​\tupdate tab_name set 字段名1 = 值1，字段名2 = 值2\u0026hellip; where条件\n注意：如果没有where条件，整个表数据都会更新。\n删除数据 语法格式：\ndelete from tab_name where\n注意 ：不加条件 删除整个表数据\n删除大表\ntruncate table teb_name;(截断，留下表头，不可回滚。永久丢失)\n约束 在创建表的时候，可以给表字段添加约束，保证表中数据合法性，完整性，有效性。\n常见约束\n非空约束（not null）：表示字段值不能为 null\n唯一约束（unique）:表示字段值不能重复，可以为null。\n主键约束pk（primary key）：表示字段既不能为null，也不能重复\n外键约束fk（foreign key）：\n唯一约束 1 2 3 4 5 create table t_user( id int, username varchar(50) UNIQUE ,#不能重复，可以为null usercode varchar(50) UNIQUE ); 1 2 3 4 5 6 create table t_user2( id int, username varchar(50) ,#不能重复，可以为null usercode varchar(50) , UNIQUE (usercode,username) # 两个字段联合起来不能重复 ); 主键约束 添加主键约束,任何一张表都应该有主键。主键表示行数据的唯一标识。一张表只能有一个主键。主键值和业务不挂钩\n1 2 3 4 5 6 7 create table t_user3( id int PRIMARY KEY AUTO_INCREMENT,#不能重复，不能为 null，自增 username varchar(50) , usercode varchar(50) ); insert INTO t_user3 VALUES (1,\u0026#39;李四\u0026#39;,\u0026#39;1001\u0026#39;); 外键约束 A表中的某个字段引用B表中的某个字段，A表为子表，B表为父表。（引用字段的表叫做子表，被引用字段的是父表）\n被引用的字段要具有唯一性，至少有UNIQUE约束。\n删除数据的时候先删除子表数据，再删除父表数据。\n插入数据的时候，先插入父表数据，然后子表。\n创建表的时候，先创建父表，再创建子表。\n删除表的时候，先删除子表，再删除父表。\n添加外键约束\n1 2 3 4 5 6 CREATE TABLE t_student( sid int PRIMARY KEY AUTO_INCREMENT, sname varchar(50), cno int , FOREIGN KEY (cno) REFERENCES t_class(cid) ) 事务 事务就是一组相关联的原子性的 SQL 语句，事务内的语句要么全部执行成功，要么全部执行失败回滚\n对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。\n要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务\n很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务\nCOMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。\n有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败：\n对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题\n事务的条件 一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）\n**原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 事务的隔离级别 mysql 的事务隔离级别是为了解决并发事务互相干扰的问题。隔离级别有四种\n读未提交（Read uncommitted）:该隔离级别的事务可以看到其他事务中未提交的数据。该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据有可能会发生回滚。因此我们把该级别读取到的数据称之为脏数据。把这个问题称之为脏读。实际开发中很少使用。\n读提交（read committed）:该隔离级别的事务能读取到其他事务以及提交的数据(不能读取其他事务未提交的数据)，解决了脏读问题。但是两次使用相同的查询可能会得到不一样的结果。这种现象叫做不可重复读。(比如：事务第一次查询数据，其他事务未提交该数据，得到结果A，第二次执行同样的查询，其他事务提交该数据，得到不同的结果B。每次查询结果都有可能不一样)\n可重复读（repeatable read）:mysql默认的事务隔离级别，该级别保证了同一个事务中多次同样读取，读取到的记录结果是一致的(该事务结束前，读取到的是备份数据)。但是理论上可重复读还是无法解决另一个幻读问题(Phantom Read)。所谓幻读指的是某个事务在读取某个范围内的记录时，另外的一个事务又在该范围插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行(Phantom Row)。InnoDB存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)解决了幻读问题；(幻读：同一个查询，在不同时间得到不同的结果，幻读读取到的是其他事务新增或者删除的“幻象”行数据。不发生在更新查询)\n和串行化也叫序列化（Serializable）:事务最高隔离级别，他会强制事务排序。但是执行效率低。使用场景不多。(操作同一个数据时，A事务不结束，B事务就排队等锁)\n注意：演示隔离级别，设置隔离级别后要退出登录，重进。隔离级别才生效。\n索引 添加索引是给某一个字段，或者某些字段添加索引\n索引就相当于一本数的目录，通过目录可以快速的找到对应的资源。查询一张表有两种方式，\n1 2 3 select ename from emp where ename = \u0026#39;xxx\u0026#39;; #当ename 字段上没有添加索引的时候，以上sql会进行全表扫描，扫描ename字段中所有的值。 #当ename 字段添加索引，以上sql语句会根据索引扫描，快速定位 全表扫描：\n根据索引检索(缩小扫描范围)：索引虽然可以提高检索效率，但是不能随意添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的经常被修改，这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。\n什么时候给字段添加索引：数据量庞大，该字段很少DML(增，删，改)操作,该字段经常出现再where子句中（经常查询哪个字段）\n注意：主键和具有unique约束的字段自动会添加索引。根据主键查询效率高。\n可以使用EXPLAIN来查看检索方式\nmysql\u0026gt; EXPLAIN select ename,sal from emp WHERE sal = 5000; +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 14 | 10.00 | Using where | +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ 1 row in set, 1 warning (0.00 sec)\ntype 字段代表检索类型。\n添加索引 给薪资字段添加索引。\n1 2 #给emp表的sal字段添加名为 emp_sal_index的索引 CREATE INDEX emp_sal_index ON emp(sal); 再次执行查询\nmysql\u0026gt; EXPLAIN select ename,sal from emp WHERE sal = 5000; +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+ | 1 | SIMPLE | emp | NULL | ref | emp_sal_index | emp_sal_index | 9 | const | 1 | 100.00 | NULL | +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+ 1 row in set, 1 warning (0.00 sec)\ntype改变了，匹配的行数rows也改变了\n删除索引 drop index 索引名称 on 表名\n索引原理\n通过B tree 缩小扫描范围，底层索引进行了排序，分析，索引会携带数据在表中的“物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。\nSelect ename from emp where ename=’smith’;\n通过索引转换为：\nSelect ename from emp where 物理地址=0x33；\n索引的分类 单一索引：给单个字段添加索引\n复合索引：给多个字段联合起来添加一个索引\n主键索引：主键上会自动添加索引\n唯一索引：有unique约束的字段上会自动添加索引\n模糊查询会使索引失效。\n数据库设计三范式 什么是设计范式 ：设计表的依据。按照三范式设计的表不会出现数据冗余。\n三范式都是哪些。\n第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分\n第二范式：建立在第一范式的基础上，所有非主键字段完全依赖主键，(没有复合主键，只有单一主键 )不能产生产生部分依赖。(所有字段依赖于一个主键，不依赖两个主键)\n第三范式：第三范式建立在第二范式基础上，所有非主键字段直接依赖主键，不能产生传递依赖。\n只要遵守三范式，表数据就不会出现冗余。\n提醒：在实际开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。\n一对一的设计：主键共享，外键唯一(fk+unique);\n一对多设计：两张表，多的表加外键。\n多对多设计：三张表，关系表两个外键\n","permalink":"https://train0405.github.io/posts/tech/mysql%E7%AC%94%E8%AE%B0/","summary":"mysql笔记 SQL 语句分类 DQL（数据查询语言）：查询语句，凡是select语句都是DQL DML（数据操作语言）：insert delete update，对表中的数据进行增删改 DDL（数据定义语言）：create drop alter，对表结构的增删改 TCL（事务控制语言）：commit提交事务，rol","title":"Mysql笔记"},{"content":"夜雨寄北\n君问归期未有期，巴山夜雨涨秋池。\n何当共剪西窗烛，却话巴山夜雨时。\n","permalink":"https://train0405.github.io/posts/life/%E8%AF%97%E6%83%85/","summary":"夜雨寄北 君问归期未有期，巴山夜雨涨秋池。 何当共剪西窗烛，却话巴山夜雨时。","title":"诗情"},{"content":" Servlet servlet的继承关系 HttpServlet\u0026mdash;\u0026gt;GenericServlet\u0026mdash;\u0026gt;Servlet\nServlet有三个重点方法\nvoid init() void service void destroy() 当发起请求是tomcat会调用service()方法。然而GenericServlet没有重写改方法，HttpServlet重写了方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 String method = req.getMethod(); long lastModified; if (method.equals(\u0026#34;GET\u0026#34;)) { lastModified = this.getLastModified(req); if (lastModified == -1L) { this.doGet(req, resp); } else { long ifModifiedSince; try { ifModifiedSince = req.getDateHeader(\u0026#34;If-Modified-Since\u0026#34;); } catch (IllegalArgumentException var9) { ifModifiedSince = -1L; } if (ifModifiedSince \u0026lt; lastModified / 1000L * 1000L) { this.maybeSetLastModified(resp, lastModified); this.doGet(req, resp); } else { resp.setStatus(304); } } } else if (method.equals(\u0026#34;HEAD\u0026#34;)) { lastModified = this.getLastModified(req); this.maybeSetLastModified(resp, lastModified); this.doHead(req, resp); } else if (method.equals(\u0026#34;POST\u0026#34;)) { this.doPost(req, resp); ///略 所以当发送请求时，会调用如上代码，先获取请求方式，各种if判断，根据请求方式不同，决定去调用不同的do方法，那么在HttpServlet中这些do方法默认都是405的实现风格-要我们子类去实现对应的方法，否则默认会报405错误。因此，我们在新建Servlet时，我们才会去考虑请求方法，从而决定重写哪个do方法\nservlet的生命周期 生命周期：对应Servlet中的三个方法:init(),service(),destroy()\n默认情况下第一次发起请求时会实例化(反射\u0026ndash;\u0026gt;构造方法)，初始化调用init()，然后服务，从第二次请求开始，每一次都是服务，当容器关闭时，会调用销毁方法。\n1 2 3 4 5 //tomcat反射使用构造器创建Class对象失败 private DemoServlet2(){ System.out.println(\u0026#34;实例化\u0026#34;); } //can not access a member of class com.train.controller.DemoServlet2 with modifiers \u0026#34;private\u0026#34; Servlet实例只会创建一个，所有的请求都是这个实例去响应(单例，不安全)\nServlet的初始化时机默认是第一次接受请求时初始化，我们可以通过来设置Servlet的启动先后顺序\n线程不安全：尽量不要在servlet中定义成员变量。如果不得不定义成员变量，那么不要去修改成员变量的值，不要根据成员变量的值做逻辑判断。\nHTTP协议 HTTP:Hyper Text Transfer Protoco超文本传输协议。HTTP最大的作用就是确定请求和响应的数据的格式，浏览器发给服务器：请求报文。服务器发给浏览器：响应报文\n请求报文：\n请求行：展示当前请求的基本信息\n请求头：通过具体的参数对本次请求进行详细说明，格式：键值对，键和值之间使用冒号隔开\n请求体：\nget方式：没有请求体，但是有一个queryString\npost:,有请求体，form data\njson格式，有请求体 request playload\n响应报文\n响应行：格式HTTP/1.1 200 OK ，含义 HHTP协议版本，响应状态码，响应状态说明文字 响应头：响应体的说明书，服务器端对浏览器端设置数据，例如：服务器端返回Cookie信息 响应体：服务器返回的数据主体，有可能是各种数据类型。 HTML页面 图片 视频 以下载形式返回的文件 CSS文件 JavaScript文件 会话 HTTP是无状态的，服务器无法区分多次请求是否是同一个客户端发起的。可以通过会话跟踪技术来解决无状态问题\n配置Servlet，启动服务器，\n1 2 3 4 5 6 7 public class DemoServlet3 extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { HttpSession session = req.getSession(); System.out.println(session.getId()); } } 浏览器第一次发请求，响应头有ssionId,与session.getId()一致。\n当第二次在发起请求时，响应头不在设置ssionid，但是请求体携带ssionid。\n所以客户端第一次发请求给服务器，服务器获取session，获取不到，则创建新的，然后响应给客户端\n下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到了，那么服务器就判断这一次请求和上次某次请求是同一个客户端，从而能够区分开客户端\n1 2 3 4 5 6 7 8 9 10 - 常用的API： request.getSession() -\u0026gt; 获取当前的会话，没有则创建一个新的会话 request.getSession(true) -\u0026gt; 效果和不带参数相同 request.getSession(false) -\u0026gt; 获取当前会话，没有则返回null，不会创建新的 session.getId() -\u0026gt; 获取sessionID session.isNew() -\u0026gt; 判断当前session是否是新的 session.getMaxInactiveInterval() -\u0026gt; session的非激活间隔时长，默认1800秒 session.setMaxInactiveInterval() session.invalidate() -\u0026gt; 强制性让会话立即失效 Servlet保存作用域的演示\n创建两个Servlet。\n1 2 3 4 5 6 7 public class DemoServlet4 extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //创建session,设置属性 req.getSession().setAttribute(\u0026#34;林黛玉\u0026#34;,15); } } 1 2 3 4 5 6 7 8 public class DemoServlet5 extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取session作用域的属性值 Object value = req.getSession().getAttribute(\u0026#34;林黛玉\u0026#34;); System.out.println(value); } } 谷歌浏览器访问两个servlet,获取到value值，因为他们是同一个session。\n然后又edge浏览器访问DemoServlet5,value 为null\n所以session保存作用域是和具体的某一个session对应的\n1 2 3 4 常用的API： void session.setAttribute(k,v) Object session.getAttribute(k) void removeAttribute(k) 服务器内部转发以及重定向 1 2 3 4 5 6 1） 服务器内部转发 : request.getRequestDispatcher(\u0026#34;...\u0026#34;).forward(request,response); - 一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的 - 地址栏没有变化 2） 客户端重定向： response.sendRedirect(\u0026#34;....\u0026#34;); - 两次请求响应的过程。客户端肯定知道请求URL有变化 - 地址栏有变化 保存作用域 原始情况下，保存作用域有4个，\npage(已经弃用) request:一次请求范围有效。 session：一次会话范围有效。 application:一次应用范围有效。 相对路径和绝对路径 相对路径：../imgs/xxx 以自己为参照物\n绝对路径: http://localhost:8080/项目名/xxx/\u0026hellip;\u0026hellip; 协议 ip 端口 项目名 文件夹 文件\n1 \u0026lt;base href=\u0026#34;http://localhost:8080/项目名/\u0026#34; /\u0026gt;的作用是，当前页面的所有路径都以这个根路径作为拼接 ","permalink":"https://train0405.github.io/posts/tech/servlet2/","summary":"Servlet servlet的继承关系 HttpServlet\u0026mdash;\u0026gt;GenericServlet\u0026mdash;\u0026gt;Servlet Servlet有三个重点方法 void init() void service void destroy() 当发起请求是tomcat会调用service()方法。然而GenericServlet没有重写改方法，HttpServlet重写了方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 String method = req.getMethod(); long lastModified; if (method.equals(\u0026#34;GET\u0026#34;)) { lastModified =","title":"Servlet2"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script language=\u0026#34;javascript\u0026#34;\u0026gt; // String str = \u0026#34;hello world\u0026#34; ; /* var str = \u0026#34;hello world\u0026#34;; alert(typeof str); str = 9999 ; alert(typeof str); */ /* var person = new Object(); person.pid = \u0026#34;p001\u0026#34;; person.pname=\u0026#34;鸠摩智\u0026#34;; alert(person.pid+\u0026#34;_\u0026#34;+person.pname); */ //java 方法 public String hello(String name){ return \u0026#34;hello to \u0026#34; + name ; } //js 方法 function hello(num1 , num2 , name){ if(num1\u0026gt;num2){ return \u0026#34;hello to\u0026#34; + name ; }else{ alert(\u0026#34;HELLO\u0026#34;); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!-- Javascript : 客户端的一个脚本语言 js是一门弱类型的语言 , 变量的数据类型由后面赋的值的类型决定 --\u0026gt; 鼠标悬浮和离开\ncss和html和js要分开\ncss\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 *{ color: threeddarkshadow; } body{ margin:0; padding:0; background-color:#808080; } div{ position:relative; float:left; } #div_container{ width:80%; height:100%; border:0px solid blue; margin-left:10%; float:left; background-color: honeydew; border-radius:8px; } #div_fruit_list{ width:100%; border:0px solid red; } #tbl_fruit{ width:60%; line-height:28px; margin-top:120px; margin-left:20%; } #tbl_fruit , #tbl_fruit tr , #tbl_fruit th , #tbl_fruit td{ border:1px solid gray; border-collapse:collapse; text-align:center; font-size:16px; font-family:\u0026#34;黑体\u0026#34;; font-weight:lighter; } .w20{ width:20%; } .delImg{ width:24px; height:24px; } .btn{ border:1px solid lightgray; width:80px; height:24px; } js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //当鼠标悬浮时，显示背景颜色 function showBGColor(){ if(event \u0026amp;\u0026amp; event.srcElement \u0026amp;\u0026amp; event.srcElement.tagName == \u0026#34;TD\u0026#34;){ var td = event.srcElement; var tr = td.parentElement; //如果想要通过js代码设置某节点的样式，则需要加上 .style tr.style.backgroundColor = \u0026#34;navy\u0026#34; ; //tr.cells表示获取这个tr中的所有的单元格 var tds = tr.cells; for(var i = 0 ; i\u0026lt;tds.length ; i++){ tds[i].style.color=\u0026#34;white\u0026#34;; } } } //当鼠标离开时，恢复原始样式 function clearBGColor(){ if(event \u0026amp;\u0026amp; event.srcElement \u0026amp;\u0026amp; event.srcElement.tagName == \u0026#34;TD\u0026#34;){ var td = event.srcElement; var tr = td.parentElement; //如果想要通过js代码设置某节点的样式，则需要加上 .style tr.style.backgroundColor = \u0026#34;transparent\u0026#34; ; //tr.cells表示获取这个tr中的所有的单元格 var tds = tr.cells; for(var i = 0 ; i\u0026lt;tds.length ; i++){ tds[i].style.color=\u0026#34;threeddarkshadow\u0026#34;; } } } //当鼠标悬浮在单价单元格时，显示手势 function showHand(){ if(event \u0026amp;\u0026amp; event.srcElement \u0026amp;\u0026amp; event.srcElement.tagName==\u0026#34;TD\u0026#34;){ var td = event.srcElement ; //cursor : 光标 td.style.cursor=\u0026#34;hand\u0026#34;; } } HTML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;demo05.css\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;demo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;div_container\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;div_fruit_list\u0026#34;\u0026gt; \u0026lt;table id=\u0026#34;tbl_fruit\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th class=\u0026#34;w20\u0026#34;\u0026gt;名称\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;w20\u0026#34;\u0026gt;单价\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;w20\u0026#34;\u0026gt;数量\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;w20\u0026#34;\u0026gt;小计\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr onmouseover=\u0026#34;showBGColor()\u0026#34; onmouseout=\u0026#34;clearBGColor()\u0026#34;\u0026gt; \u0026lt;td\u0026gt;苹果\u0026lt;/td\u0026gt; \u0026lt;td onmouseover=\u0026#34;showHand()\u0026#34;\u0026gt;5\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;20\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; class=\u0026#34;delImg\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr onmouseover=\u0026#34;showBGColor()\u0026#34; onmouseout=\u0026#34;clearBGColor()\u0026#34;\u0026gt; \u0026lt;td\u0026gt;西瓜\u0026lt;/td\u0026gt; \u0026lt;td onmouseover=\u0026#34;showHand()\u0026#34;\u0026gt;3\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;20\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;60\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; class=\u0026#34;delImg\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr onmouseover=\u0026#34;showBGColor()\u0026#34; onmouseout=\u0026#34;clearBGColor()\u0026#34;\u0026gt; \u0026lt;td\u0026gt;菠萝\u0026lt;/td\u0026gt; \u0026lt;td onmouseover=\u0026#34;showHand()\u0026#34;\u0026gt;4\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;25\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; class=\u0026#34;delImg\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr onmouseover=\u0026#34;showBGColor()\u0026#34; onmouseout=\u0026#34;clearBGColor()\u0026#34;\u0026gt; \u0026lt;td\u0026gt;榴莲\u0026lt;/td\u0026gt; \u0026lt;td onmouseover=\u0026#34;showHand()\u0026#34;\u0026gt;3\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;30\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;90\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; class=\u0026#34;delImg\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;总计\u0026lt;/td\u0026gt; \u0026lt;td colspan=\u0026#34;4\u0026#34;\u0026gt;999\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面的html还是嵌套太多js调用，现在改进一下\nhtml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/demo05.css\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;js/demo08.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;div_container\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;div_fruit_list\u0026#34;\u0026gt; \u0026lt;table id=\u0026#34;tbl_fruit\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th class=\u0026#34;w20\u0026#34;\u0026gt;名称\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;w20\u0026#34;\u0026gt;单价\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;w20\u0026#34;\u0026gt;数量\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;w20\u0026#34;\u0026gt;小计\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;苹果\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;5\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;20\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; class=\u0026#34;delImg\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\t\u0026lt;td\u0026gt;西瓜\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;20\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;60\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; class=\u0026#34;delImg\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;菠萝\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;4\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;25\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; class=\u0026#34;delImg\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;榴莲\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;30\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;90\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; class=\u0026#34;delImg\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;总计\u0026lt;/td\u0026gt; \u0026lt;td colspan=\u0026#34;4\u0026#34;\u0026gt;999\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 window.onload=function(){ updateZJ(); //当页面加载完成，我们需要绑定各种事件 //根据id获取到表格 var fruitTbl = document.getElementById(\u0026#34;tbl_fruit\u0026#34;); //获取表格中的所有的行 var rows = fruitTbl.rows ; for(var i = 1 ; i\u0026lt;rows.length-1 ; i++){ var tr = rows[i]; //1.绑定鼠标悬浮以及离开时设置背景颜色事件 tr.onmouseover=showBGColor; tr.onmouseout=clearBGColor; //获取tr这一行的所有单元格 var cells = tr.cells; var priceTD = cells[1]; //2.绑定鼠标悬浮在单价单元格变手势的事件 priceTD.onmouseover = showHand ; } } //当鼠标悬浮时，显示背景颜色 function showBGColor(){ //event : 当前发生的事件 //event.srcElement : 事件源 //alert(event.srcElement); //alert(event.srcElement.tagName);\t--\u0026gt; TD if(event \u0026amp;\u0026amp; event.srcElement \u0026amp;\u0026amp; event.srcElement.tagName==\u0026#34;TD\u0026#34;){ var td = event.srcElement ; //td.parentElement 表示获取td的父元素 -\u0026gt; TR var tr = td.parentElement ; //如果想要通过js代码设置某节点的样式，则需要加上 .style tr.style.backgroundColor = \u0026#34;navy\u0026#34; ; //tr.cells表示获取这个tr中的所有的单元格 var tds = tr.cells; for(var i = 0 ; i\u0026lt;tds.length ; i++){ tds[i].style.color=\u0026#34;white\u0026#34;; } } } //当鼠标离开时，恢复原始样式 function clearBGColor(){ if(event \u0026amp;\u0026amp; event.srcElement \u0026amp;\u0026amp; event.srcElement.tagName==\u0026#34;TD\u0026#34;){ var td = event.srcElement ; var tr = td.parentElement ; tr.style.backgroundColor=\u0026#34;transparent\u0026#34;; var tds = tr.cells; for(var i = 0 ; i\u0026lt;tds.length ; i++){ tds[i].style.color=\u0026#34;threeddarkshadow\u0026#34;; } } } //当鼠标悬浮在单价单元格时，显示手势 function showHand(){ if(event \u0026amp;\u0026amp; event.srcElement \u0026amp;\u0026amp; event.srcElement.tagName==\u0026#34;TD\u0026#34;){ var td = event.srcElement ; //cursor : 光标 td.style.cursor=\u0026#34;hand\u0026#34;; } } ","permalink":"https://train0405.github.io/posts/tech/js/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script language=\u0026#34;javascript\u0026#34;\u0026gt; // String str = \u0026#34;hello world\u0026#34; ; /* var str = \u0026#34;hello world\u0026#34;; alert(typeof str); str = 9999 ; alert(typeof str); */ /* var person = new Object(); person.pid = \u0026#34;p001\u0026#34;; person.pname=\u0026#34;鸠摩智\u0026#34;; alert(person.pid+\u0026#34;_\u0026#34;+person.pname); */ //java 方法 public String hello(String name){ return \u0026#34;hello to \u0026#34; + name ; } //js 方法 function hello(num1 , num2 , name){ if(num1\u0026gt;num2){ return \u0026#34;hello to\u0026#34; +","title":"Js"},{"content":" Servlert 1.IDEA安装配置好tomcat\n2.导入tomcat jar包\n3.前端html form表单\n1 2 3 4 5 6 7 \u0026lt;form action=\u0026#34;add\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 名称：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;fname\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; 价格：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;price\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; 库存：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;fcount\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; 备注：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;remark\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;添加\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 4.AddServlet类\n1 2 3 4 5 6 7 8 public class AddServlet extends HttpServlet { //继承重写方法，子类的修饰符可以比父类大或者相等 @Override public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;收到\u0026#34;); } } 5.编写web.xml 建立http请求和服务端的映射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;AddServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- 处理程序--\u0026gt; \u0026lt;servlet-class\u0026gt;com.train.servlets.AddServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!-- 映射，用户请求映射的Servlet--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;!-- 寻找对应的处理程序--\u0026gt; \u0026lt;servlet-name\u0026gt;AddServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- 用户发送请求地址--\u0026gt; \u0026lt;url-pattern\u0026gt;/add\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!-- 1. 用户发请求，action=add 2. 项目中，web.xml中找到url-pattern = /add -\u0026gt; 第12行 3. 找第11行的servlet-name = AddServlet 4. 找和servlet-mapping中servlet-name一致的servlet ， 找到第7行 5. 找第8行的servlet-class -\u0026gt; com.atguigu.servlets.AddServlet 6. 用户发送的是post请求（method=post） ， 因此 tomcat会执行AddServlet中的doPost方法 --\u0026gt; \u0026lt;/web-app\u0026gt; 6.启动服务端，测试成功(artifact是部署包)\n7.接收form表单数据\n1 2 3 4 5 6 7 8 9 10 public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String header = req.getParameter(\u0026#34;fname\u0026#34;); //接受的请求头字段都是字符串，需要将Integer解析为String String priceStr = req.getParameter(\u0026#34;price\u0026#34;); Integer price = Integer.parseInt(priceStr); String count = req.getParameter(\u0026#34;fcount\u0026#34;); String remark = req.getParameter(\u0026#34;remark\u0026#34;); System.out.println(header); } 数据写到数据库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class AddServetDaoImpl implements AddServetDao { public static final String URL = \u0026#34;jdbc:mysql://localhost:3306/fruitdb?characterEncoding=UTF8\u0026amp;useSSL=false\u0026#34;; public static final String USER = \u0026#34;root\u0026#34;; public static final String PASSWORD = \u0026#34;12345\u0026#34;; private static Connection conn = null; static{ try { //1.加载驱动程序 Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); //2. 获得数据库连接 conn = DriverManager.getConnection(URL, USER, PASSWORD); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } } public void add(Fruit f) { //获取连接 // Connection conn = DbUtil.getConnection(); //sql String sql = \u0026#34;INSERT INTO t_fruit( fname, price, fcount, remark)\u0026#34; +\u0026#34;values(?,?,?,?)\u0026#34;; //预编译 PreparedStatement ptmt; try { ptmt= conn.prepareStatement(sql); //预编译SQL，减少sql执行 ptmt.setString(1,f.getFname()); ptmt.setInt(2,f.getPrice()); ptmt.setInt(3,f.getFcount()); ptmt.setString(4,f.getRemark()); ptmt.execute(); } catch (SQLException e) { throw new RuntimeException(e); } } tomcat部署情况下，添加jar包的步骤\n1.jar包放到web/web-inf/lib/jar/文件夹下\n2.project structure\u0026mdash;\u0026gt;artifacts\u0026mdash;\u0026gt;删除部署包(artifact)\u0026mdash;\u0026gt;重新添加部署包\n原因：后面添加的jar包没有添加到部署包去。重新添加即可。\n","permalink":"https://train0405.github.io/posts/tech/servlet/","summary":"Servlert 1.IDEA安装配置好tomcat 2.导入tomcat jar包 3.前端html form表单 1 2 3 4 5 6 7 \u0026lt;form action=\u0026#34;add\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 名称：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;fname\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; 价格：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;price\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; 库存：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;fcount\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; 备注：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;remark\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;添加\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 4.AddS","title":"Servlet"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;!-- 内部样式表 --\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; /* 被style标签包围的范围是CSS环境，可以写CSS代码 */ /* 标签样式表 */ p{ color:red; } /* 类样式 */ .f20{ font-size:20px; } \u0026lt;/style\u0026gt; \u0026lt;!-- 引用外部的CSS样式表文件 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/demo01.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- \u0026lt;p\u0026gt;\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;这里是段落一\u0026lt;/font\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;这里是段落二\u0026lt;/font\u0026gt;\u0026lt;/p\u0026gt; --\u0026gt; \u0026lt;p\u0026gt;这里是段落一\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;这里是段落二\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;f20\u0026#34;\u0026gt;这里是段落三\u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;p4\u0026#34;\u0026gt;这里是段落四\u0026lt;/p\u0026gt;\t\u0026lt;!-- id属性在整个HTML文档中，尽量保持唯一（虽然重复也不会报错） --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span style=\u0026#34;font-size:60px;font-weight:bolder;color:yellow;\u0026#34;\u0026gt;HELLO\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;span class=\u0026#34;f32\u0026#34;\u0026gt;World\u0026lt;/span\u0026gt; \u0026lt;p class=\u0026#34;f32\u0026#34;\u0026gt;!!!\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!-- 1. 为什么需要CSS 2. CSS的最基本的分类: 标签样式表、类样式表、ID样式表 3. CSS从位置上的分类： 嵌入式样式表、\u0026lt;p\u0026gt;\u0026lt;span style=\u0026#34;font-size:60px;font-weight:bolder;color:yellow;\u0026#34;\u0026gt;HELLO\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; 内部样式表、\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; 外部样式表\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/demo01.css\u0026#34;\u0026gt; --\u0026gt; CSS页面布局\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body{ margin:0; padding:0; } #div1{ width:200px; height:50px; background-color:greenyellow; /* 绝对定位 */ position:absolute; left:100px; top:100px; } #div2{ width:200px; height:50px; background-color:pink; position:relative; float:left; margin-left:20px; } #div3{ height:50px; background-color:darkorange; } #div4{ width:200px; height:50px; background-color:aqua; float:left; } #div5{ width:200px; height:50px; background-color:olivedrab; float:left; } div{ position:relative; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div2\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;div id=\u0026#34;div3\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;div4\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div5\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!-- position: absolute -- 绝对定位 , 需要配合使用 left , top relative -- 相对定位 , 一般会和 float , margin , padding .... 一起使用 float --\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body{ margin:0; padding:0; background-color:#808080; } div{ position:relative; } #div_top{ background-color: orange; height:20%; } #div_left{ background-color: greenyellow; height:80%; width:15%; float:left; } #div_main{ background-color: whitesmoke; height:70%; float:left; width:85%; } #div_bottom{ background-color: sandybrown; height:10%; width:85%; float:left; } #div_container{ width:80%; height:100%; border:0px solid blue; margin-left:10%; float:left; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;div_container\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;div_top\u0026#34;\u0026gt;div_top\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div_left\u0026#34;\u0026gt;div_left\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div_main\u0026#34;\u0026gt;div_main\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div_bottom\u0026#34;\u0026gt;div_bottom\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://train0405.github.io/posts/tech/css/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;!-- 内部样式表 --\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; /* 被style标签包围的范围是CSS环境，可以写CSS代码 */ /* 标签样式表 */ p{ color:red; } /* 类样式 */ .f20{ font-size:20px; } \u0026lt;/style\u0026gt; \u0026lt;!-- 引用外部的CSS样式表文件 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/demo01.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- \u0026lt;p\u0026gt;\u0026lt;font color=\u0026#3","title":"Css"},{"content":" HTML 超文本标记语言，决定页面显示内容，解释型语言，浏览器会重第一行开始解释都结尾\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;这是我的第一个网页\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- HELLO WORLD!\u0026lt;br/\u0026gt;你好，HTML！ \u0026lt;p\u0026gt;这里是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;这里是第二个段落\u0026lt;/p\u0026gt; \u0026lt;img src=\u0026#34;D:\\sgg2021\\0927_javaweb\\1109\\02.代码\\imgs\\girl.jpg\u0026#34; width=\u0026#34;57\u0026#34; height=\u0026#34;73\u0026#34; alt=\u0026#34;这里是一张图片\u0026#34;/\u0026gt; \u0026lt;h1\u0026gt;标题一\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;标题一\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;标题一\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;标题一\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;标题一\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;标题一\u0026lt;/h6\u0026gt; --\u0026gt; 武林高手排行榜: \u0026lt;ol type=\u0026#34;i\u0026#34; start=\u0026#34;3\u0026#34;\u0026gt; \u0026lt;li\u0026gt;扫地僧\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;萧远山\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;慕容博\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;虚竹\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;阿紫\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 武林大会人员名单： \u0026lt;ul type=\u0026#34;circle\u0026#34;\u0026gt; \u0026lt;li\u0026gt;乔峰\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;阿朱\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;马夫人\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;白世镜\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 你是\u0026lt;b\u0026gt;\u0026lt;i\u0026gt;\u0026lt;u\u0026gt;喜欢\u0026lt;/u\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt;是\u0026lt;b\u0026gt;甜\u0026lt;/b\u0026gt;月饼还是\u0026lt;i\u0026gt;咸\u0026lt;/i\u0026gt;\u0026lt;u\u0026gt;月饼\u0026lt;/u\u0026gt;？ \u0026lt;br/\u0026gt; 水分子的化学式： H\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;O \u0026lt;br/\u0026gt; 氧气的化学式： O\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;\u0026lt;br/\u0026gt; 5\u0026amp;lt;10 10\u0026amp;gt;5 5\u0026amp;le;10 10\u0026amp;ge;5 注册商标 \u0026amp;reg; 版权符号 \u0026amp;copy; \u0026lt;span\u0026gt;赵又廷\u0026lt;/span\u0026gt;，夺妻之仇。 \u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; target=\u0026#34;_self\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!-- 1) html语言是解释型语言，不是编译型 浏览器是容错的 2) html页面中由一对标签组成：\u0026lt;html\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;html\u0026gt; 称之为 开始标签 \u0026lt;/html\u0026gt;称之为 结束标签 3) title 表示网页的标题 4) 可以在meta标签中设置编码方式 5) \u0026lt;br/\u0026gt;表示换行 。br标签是一个单标签。单标签：开始标签和结束标签是同一个，斜杠放在单词后面 6) p 表示段落标签 7) img 标签图片标签 src属性表示图片文件的路径 width和height表示图片的大小 alt表示图片的提示 8) 路径的问题： 1. 相对路径 2. 绝对路径 9) h1~h6 : 标题标签 10) 列表标签: - ol 有序列表 start 表示从*开始，type 显示的类型：A a I i 1(deafult) - ul 无序列表 type disc(default) , circle , square 11) u 下划线 b 粗体 i 斜体 12) 上标 sup 下标 sub 13) HTML中的实体： 小于号 \u0026amp;lt; 大于等于号 \u0026amp;ge; 版权 \u0026amp;copy; 14) span 不换行的块标记 15) a 表示超链接 href 链接的地址 target: _self 在本窗口打开 _blank 在一个新窗口打开 _parent 在父窗口打开 _top 在顶层窗口打开 16) div 层 --\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;表格标签的学习\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; width=\u0026#34;600\u0026#34; cellspacing=\u0026#34;0\u0026#34; cellpadding=\u0026#34;4\u0026#34;\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;门派\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;成名绝技\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;内功值\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;乔峰\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;丐帮\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;少林长拳\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;5000\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;虚竹\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;灵鹫宫\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;北冥神功\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;15000\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;扫地僧\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;少林寺\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;七十二绝技\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;未知\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;hr/\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; cellpadding=\u0026#34;4\u0026#34; width=\u0026#34;600\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;名称\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;单价\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;数量\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;小计\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;苹果\u0026lt;/td\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34;\u0026gt;5\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;20\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;菠萝\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;15\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;45\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;西瓜\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;6\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;6\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;36\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;imgs/del.jpg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;总计\u0026lt;/td\u0026gt; \u0026lt;td colspan=\u0026#34;4\u0026#34;\u0026gt;181\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!-- 17) 表格\ttable 行\ttr 列\ttd 表头列\tth table中有如下属性（虽然已经淘汰，但是最好了解一下） - border：表格边框的粗细 - width:表格的宽度 - cellspacing：单元格间距 - cellpadding：单元格填充 tr中有一个属性： align -\u0026gt; center , left , right rowspan : 行合并 colspan : 列合并 ","permalink":"https://train0405.github.io/posts/tech/html/","summary":"HTML 超文本标记语言，决定页面显示内容，解释型语言，浏览器会重第一行开始解释都结尾 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101","title":"HTML"},{"content":" Java 网络编程 网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。\njava.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。\njava.net 包中提供了两种常见的网络协议的支持：\nTCP：TCP（英语：Transmission Control Protocol，传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP 层是位于 IP 层之上，应用层之下的中间层。TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。 UDP：UDP （英语：User Datagram Protocol，用户数据报协议），位于 OSI 模型的传输层。一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。 Socket 编程 套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。\n当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。\njava.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。\n以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：\n服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。 Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。 连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。\nTCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 socket。\nServerSocket 类的方法 服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。\nServerSocket 类有四个构造方法：\n序号 方法描述 1 public ServerSocket(int port) throws IOException 创建绑定到特定端口的服务器套接字。 2 public ServerSocket(int port, int backlog) throws IOException 利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。 3 public ServerSocket(int port, int backlog, InetAddress address) throws IOException 使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。 4 public ServerSocket() throws IOException 创建非绑定服务器套接字。 这里有一些 ServerSocket 类的常用方法：\n序号 方法描述 1 public int getLocalPort() 返回此套接字在其上侦听的端口。 2 public Socket accept() throws IOException 侦听并接受到此套接字的连接。 3 public void setSoTimeout(int timeout) 通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。 4 public void bind(SocketAddress host, int backlog) 将 ServerSocket 绑定到特定地址（IP 地址和端口号）。 Socket 类的方法 java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。\nSocket 类有五个构造方法\n序号 方法描述 1 public Socket(String host, int port) throws UnknownHostException, IOException. 创建一个流套接字并将其连接到指定主机上的指定端口号。 2 public Socket(InetAddress host, int port) throws IOException 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 3 public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException. 创建一个套接字并将其连接到指定远程主机上的指定远程端口。 4 public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException. 创建一个套接字并将其连接到指定远程地址上的指定远程端口。 5 public Socket() 通过系统默认类型的 SocketImpl 创建未连接套接字 当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。\n下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。\n序号 方法描述 1 public void connect(SocketAddress host, int timeout) throws IOException 将此套接字连接到服务器，并指定一个超时值。 2 public InetAddress getInetAddress() 返回套接字连接的地址。 3 public int getPort() 返回此套接字连接到的远程端口。 4 public int getLocalPort() 返回此套接字绑定到的本地端口。 5 public SocketAddress getRemoteSocketAddress() 返回此套接字连接的端点的地址，如果未连接则返回 null。 6 public InputStream getInputStream() throws IOException 返回此套接字的输入流。 7 public OutputStream getOutputStream() throws IOException 返回此套接字的输出流。 8 public void close() throws IOException 关闭此套接字。 InetAddress 类的方法 这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法：\n序号 方法描述 1 static InetAddress getByAddress(byte[] addr) 在给定原始 IP 地址的情况下，返回 InetAddress 对象。 2 static InetAddress getByAddress(String host, byte[] addr) 根据提供的主机名和 IP 地址创建 InetAddress。 3 static InetAddress getByName(String host) 在给定主机名的情况下确定主机的 IP 地址。 4 String getHostAddress() 返回 IP 地址字符串（以文本表现形式）。 5 String getHostName() 获取此 IP 地址的主机名。 6 static InetAddress getLocalHost() 返回本地主机。 7 String toString() 将此 IP 地址转换为 String。 Socket 客户端实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main(String[] args) throws IOException { String serverName = \u0026#34;localhost\u0026#34;; int port = 8888; System.out.println(\u0026#34;连接到主机：\u0026#34; + serverName + \u0026#34; ，端口号：\u0026#34; + port); Socket client = new Socket(serverName,port); System.out.println(\u0026#34;远程主机地址：\u0026#34; + client.getRemoteSocketAddress()); OutputStream outToServer = client.getOutputStream(); DataOutputStream out = new DataOutputStream(outToServer); out.writeUTF(\u0026#34;Hello from \u0026#34; + client.getLocalSocketAddress()); //读取返回 InputStream inFromServer = client.getInputStream(); DataInputStream in = new DataInputStream(inFromServer); System.out.println(\u0026#34;服务器响应： \u0026#34; + in.readUTF()); client.close(); } Socket 服务端实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class GreetingServer { private ServerSocket serverSocket; public GreetingServer(int port) throws IOException { serverSocket = new ServerSocket(port); serverSocket.setSoTimeout(10000); } public void run() throws IOException { while (true){ System.out.println(\u0026#34;等待远程连接，端口号为: \u0026#34;+serverSocket.getLocalPort()+\u0026#34;...\u0026#34;); Socket server = serverSocket.accept(); System.out.println(\u0026#34;远程主机地址：\u0026#34;+server.getRemoteSocketAddress()); InputStream is = server.getInputStream(); DataInputStream in = new DataInputStream(is); System.out.println(\u0026#34;in.readUTF\u0026#34;+in.readUTF()); //反馈消息 OutputStream os = server.getOutputStream(); DataOutputStream ou = new DataOutputStream(os); ou.writeUTF(\u0026#34;谢谢连接我：\u0026#34; + server.getLocalSocketAddress() + \u0026#34;\\nGoodbye!\u0026#34;); server.close(); } } public static void main(String[] args) throws IOException { GreetingServer greetingServer = new GreetingServer(8888); greetingServer.run(); } } ","permalink":"https://train0405.github.io/posts/tech/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","summary":"Java 网络编程 网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。 java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。 java.net 包中提供了两种常见的网络协议的支持： TCP：TCP（英语：Transmi","title":"网络编程"},{"content":" Java 多线程 Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。\n一个线程的生命周期 线程是一个动态执行的过程，它也有一个从产生到死亡的过程。\n下图显示了一个线程完整的生命周期。\n新建状态:\n​ 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。\n1 2 //新建状态 Thread thread = new SubThread(); 就绪状态:\n当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。\n1 2 //就绪状态，在就绪队列中等待调度 thrad.start(); 运行状态:\n如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。\n阻塞状态:\n如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：\n等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态:\n一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。\n线程的优先级 每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。\nJava 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。\n默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。\n具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台\n创建一个线程 Java 提供了三种创建线程的方法：\n通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过实现 Runnable 接口来创建线程 创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。\n下面是一个创建线程并开始让它执行的实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public static void main(String[] args) { RunnableDemo r1 = new RunnableDemo(\u0026#34;线程1\u0026#34;); r1.start(); RunnableDemo r2 = new RunnableDemo(\u0026#34;线程2\u0026#34;); r2.start(); } } class RunnableDemo implements Runnable{ public RunnableDemo(String threadName) { this.threadName = threadName; System.out.println(\u0026#34;creating\u0026#34;+threadName); } Thread thread = null; String threadName; @Override public void run() { System.out.println(\u0026#34;Running Thread\u0026#34; + threadName); try { for (int i = 4; i \u0026gt; 0; i--) { System.out.println(\u0026#34;Thread: \u0026#34; + threadName + \u0026#34;, \u0026#34; + i); Thread.sleep(10); } } catch (Exception e) { System.out.println(\u0026#34;Thread \u0026#34; + threadName + \u0026#34; interrupted.\u0026#34;); } System.out.println(Thread.currentThread().getName() + \u0026#34;exiting\u0026#34;); } public void start(){ System.out.println(\u0026#34;Starting \u0026#34; + threadName ); if (thread == null){ thread = new Thread(this,threadName); thread.start(); } } 通过继承Thread来创建线程 创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。\n继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。\n该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public static void main(String[] args) { ThreadDemo thread1 = new ThreadDemo(\u0026#34;线程1\u0026#34;); ThreadDemo thread2 = new ThreadDemo(\u0026#34;线程2\u0026#34;); thread1.start(); thread2.start(); } } class ThreadDemo extends Thread{ Thread thread = null; String threadName; public ThreadDemo(String threadName) { this.threadName = threadName; System.out.println(\u0026#34;creating\u0026#34;+threadName); } @Override public void run() { System.out.println(\u0026#34;Running Thread\u0026#34;+ threadName); for (int i=4;i\u0026gt;0;i--){ System.out.println(\u0026#34;Thread \u0026#34;+threadName+i); } System.out.println(\u0026#34;Thread\u0026#34;+threadName+\u0026#34;exiting\u0026#34;); } public void start(){ if (thread == null){ System.out.println(\u0026#34;starting\u0026#34;+threadName); thread = new Thread(this,threadName); thread.start(); } } Thread 方法 sleep(long) :让线程睡眠指定毫秒数。线程进入阻塞状态\nwait():当前线程进入阻塞状态，一旦执行wait()会释放同步监视器\nsleep和wait的区别：\n相同点：\nsleep() 和 wait() 调用都会暂停当前线程并让出 CPU\n不同点：\nThread类中声明sleep，Object类中声明wait\n调用要求不同，sleep()可以在任何需要的场景下调用，wait必须在同步代码块调用。\n锁资源释放方式不同：sleep 方法只让出了CPU，没有释放同步资源锁！ wait方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行\n恢复方式不同：sleep调用后停止运行期间仍持有同步锁，所以到时间会继续执行；wait调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，再次获得对象锁后才会进入运行状态，在没有获取对象锁之前不会继续执行；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class ThreadClassDemo { public static void main(String [] args) { Runnable hello = new DisplayMessage(\u0026#34;Hello\u0026#34;); Thread thread1 = new Thread(hello); //设置守护线程,当用户线程结束也跟着结束 thread1.setDaemon(true); thread1.setName(\u0026#34;守护线程hello\u0026#34;); System.out.println(\u0026#34;Starting 守护线程hello thread...\u0026#34;); thread1.start(); Runnable bye = new DisplayMessage(\u0026#34;Goodbye\u0026#34;); Thread thread2 = new Thread(bye); //设置优先级 thread2.setPriority(Thread.MIN_PRIORITY); //守护线程 thread2.setDaemon(true); System.out.println(\u0026#34;Starting goodbye thread...\u0026#34;); thread2.start(); System.out.println(\u0026#34;Starting thread3...\u0026#34;); Thread thread3 = new GuessANumber(27); thread3.start(); try { // 插队，线程并行变串行，等thread3执行完毕才会执行其他线程 thread3.join(); }catch(InterruptedException e) { System.out.println(\u0026#34;Thread interrupted.\u0026#34;); } System.out.println(\u0026#34;Starting thread4...\u0026#34;); Thread thread4 = new GuessANumber(75); thread4.start(); System.out.println(\u0026#34;main() is ending...\u0026#34;); } } class DisplayMessage implements Runnable{ public DisplayMessage(String message) { this.message = message; } String message; @Override public void run() { while (true){ System.out.println(message); } } } class GuessANumber extends Thread{ int number; public GuessANumber(int number) { this.number = number; } @Override public void run() { int counter = 0; int guess = 0; do{ guess = (int) (Math.random() * 100 + 1); System.out.println(this.getName() + \u0026#34; guesses \u0026#34; + guess); counter++; }while (guess != number); System.out.println(\u0026#34;** Correct!\u0026#34; + this.getName() + \u0026#34;in\u0026#34; + counter + \u0026#34;guesses.**\u0026#34;); } } 通过 Callable 和 Future 创建线程 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。 .使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。\n调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。 call()方法可以有返回值。\ncall()方法可以声明抛出异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class CallableThreadTest implements Callable\u0026lt;Integer\u0026gt; { public static void main(String[] args) { CallableThreadTest ctt = new CallableThreadTest(); FutureTask\u0026lt;Integer\u0026gt; ft = new FutureTask\u0026lt;\u0026gt;(ctt); for(int i = 0;i \u0026lt; 100;i++) { System.out.println(Thread.currentThread().getName()+\u0026#34; 的循环变量i的值\u0026#34;+i); if(i==20) { new Thread(ft,\u0026#34;有返回值的线程\u0026#34;).start(); } } try { System.out.println(\u0026#34;子线程的返回值：\u0026#34;+ft.get()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } @Override public Integer call() throws Exception { int i = 0; for(;i\u0026lt;100;i++) { System.out.println(Thread.currentThread().getName()+\u0026#34; \u0026#34;+i); } return i; } } 参考文献\nhttps://www.runoob.com/java/java-multithreading.html\n线程安全 关键字synchronized\n实现方式\n1 2 3 4 //如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁， synchronized( 需要一个任意的对象（锁） ){ 代码块中放操作共享数据的代码。 } 线程释放锁：\n获取锁的线程执行完了该代码块，然后线程释放对锁的占有； 线程执行发生异常，此时JVM会让线程自动释放锁 Lock\n常用方法：\n方法名 描述 void lock() 获取锁，如锁被占用，则等待。 boolean tryLock() 尝试获取锁（成功返回true。失败返回false，不阻塞）。 void unlock() 释放锁。 ReentrantLock\nLock接口的实现类。\n读写锁\nReentrantReadWriteLock：\n一种支持一写多读的同步锁，读写分离，可分别分配读锁、写锁。 支持多次分配读锁，使多个读操作可以并发执行。 线程池 为什么需要线程池? 如果有非常的多的任务需要多线程来完成，且每个线程执行时间不会太长，这样频繁的创建和销毁线程。 频繁创建和销毁线程会比较耗性能。有了线程池就不要创建更多的线程来完成任务，因为线程可以重用 线程池原理 线程池用维护者一个队列，队列中保存着处于等待（空闲）状态的线程。不用每次都创建新的线程\n线程池API 常用的线程池接口和类(所在包java.util.concurrent)。\nExecutor：线程池的顶级接口。\nExecutorService：线程池接口，可通过submit(Runnable task) 提交任务代码。\nExecutors工厂类：通过此类可以获得一个线程池。\n方法名 描述 newFixedThreadPool(int nThreads) 获取固定数量的线程池。参数：指定线程池中线程的数量。 newCachedThreadPool() 获得动态数量的线程池，如不够则创建新的，无上限。 newSingleThreadExecutor() 创建单个线程的线程池，只有一个线程。 newScheduledThreadPool() 创建固定大小的线程池，可以延迟或定时执行任务。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class TestThreadPool { public static void main(String[] args) { //1.1创建固定线程个数的线程池 //ExecutorService es=Executors.newFixedThreadPool(4); //1.2创建缓存线程池，线程个数由任务个数决定 ExecutorService es= Executors.newCachedThreadPool(); //1.3创建单线程线程池 //Executors.newSingleThreadExecutor(); //1.4创建调度线程池 调度:周期、定时执行 //Executors.newScheduledThreadPool(corePoolSize) Executors.newScheduledThreadPool(3); //2创建任务 Runnable runnable=new Runnable() { private int ticket=100; @Override public void run() { while(true) { if(ticket\u0026lt;=0) { break; } System.out.println(Thread.currentThread().getName()+\u0026#34;买了第\u0026#34;+ticket+\u0026#34;张票\u0026#34;); ticket--; } } }; //3提交任务 for(int i=0;i\u0026lt;5;i++) { es.submit(runnable); } //4关闭线程池 es.shutdown();//等待所有任务执行完毕 然后关闭线程池，不接受新任务。 } } ","permalink":"https://train0405.github.io/posts/tech/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"Java 多线程 Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 一个线程的生命周期 线程是一个动态执行的过程，它也有一个从产生到死亡的过程。 下图显示了一个线程完整的生命周期。 新建状态: ​ 使用 new 关键字和 Thread 类或其","title":"多线程"},{"content":" Java 反射(Reflection) 在Java中，反射允许我们在运行时检查和操作类、接口、构造函数、方法和字段。\nJava 类名为Class 在学习Java反射之前，我们需要了解一个名为Class的Java类。\nJava中有一个名为Class的类，该类在运行时保留有关对象和类的所有信息。\nClass对象描述了特定类的属性。该对象用于执行反射。\n创建名为Class的类的对象 1 2 3 4 5 6 7 8 9 //forName()接受字符串参数（类的名称）并返回Class对象 Class\u0026lt;?\u0026gt; dog = Class.forName(\u0026#34;com.x.x.Dog\u0026#34;); //getClass()方法使用特定类的对象来创建新的对象Class。 Dog d1 = new Dog(); Class c1 = d1.getClass(); //使用.class Class c2 = Dog.class; System.out.println(dog == c1); System.out.println(c1 == c2); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.lang.Class; import java.lang.reflect.*; interface Animal { public void display(); } interface Mammal { public void makeSound(); } class Dog implements Animal, Mammal { public void display() { System.out.println(\u0026#34;I am a dog.\u0026#34;); } public void makeSound() { System.out.println(\u0026#34;Bark bark\u0026#34;); } } class ReflectionDemo { public static void main(String[] args) { try { //创建一个Dog类的对象 Dog d1 = new Dog(); //使用getClass()创建Class对象 Class obj = d1.getClass(); //查找由Dog实现的接口 Class[] objInterface = obj.getInterfaces(); for(Class c : objInterface) { //打印接口名称 System.out.println(\u0026#34;Interface Name: \u0026#34; + c.getName()); } } catch(Exception e) { e.printStackTrace(); } } } 反射字段，方法和构造函数 该软件包java.lang.reflect提供了可用于操作类成员的类。例如，\n方法类 - 提供有关类中方法的信息 字段类 - 提供有关类中字段的信息 构造函数类 - 提供有关类中构造函数的信息 Java 反射与字段 我们可以使用Field类提供的各种方法检查和修改类的不同字段。\ngetFields() - 返回该类及其超类的所有公共字段 getDeclaredFields() - 返回类的所有字段 getModifier() - 以整数形式返回字段的修饰符 set(classObject,value) - 使用指定的值设置字段的值 get(classObject) - 获取字段的值 setAccessible(boolean) - 使私有字段可访问 **注意：**如果我们知道字段名称，则可以使用\ngetField(\u0026ldquo;fieldName\u0026rdquo;） - 从类返回名称为fieldName的公共字段。 getDeclaredField*(\u0026ldquo;fieldName\u0026rdquo;）* - 从类返回名称为fieldName的字段。 示例：访问公共字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Dog { public String type; } class ReflectionDemo { public static void main(String[] args) { try{ Dog d1 = new Dog(); //创建Class对象 Class obj = d1.getClass(); //操纵Dog类的公共字段type Field field1 = obj.getField(\u0026#34;type\u0026#34;); //设置字段的值 field1.set(d1, \u0026#34;labrador\u0026#34;); //通过转换成字符串来获取字段的值 String typeValue = (String)field1.get(d1); System.out.println(\u0026#34;type: \u0026#34; + typeValue); //获取类型的访问修饰符 int mod1 = field1.getModifiers(); String modifier1 = Modifier.toString(mod1); System.out.println(\u0026#34;修饰符： \u0026#34; + modifier1); System.out.println(\u0026#34; \u0026#34;); } catch(Exception e) { e.printStackTrace(); } } } Java 反射与方法 像字段一样，我们可以使用Method类提供的各种方法来检查类的不同方法。\ngetMethods() - 返回该类及其超类的所有公共方法 getDeclaredMethod() - 返回该类的所有方法 getName() - 返回方法的名称 getModifiers() - 以整数形式返回方法的访问修饰符 getReturnType() - 返回方法的返回类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Dog { public void display() { System.out.println(\u0026#34;I am a dog.\u0026#34;); } protected void eat() { System.out.println(\u0026#34;I eat dog food.\u0026#34;); } private void makeSound() { System.out.println(\u0026#34;Bark Bark\u0026#34;); } } class ReflectionDemo { public static void main(String[] args) { try { Dog d1 = new Dog(); //创建一个Class对象 Class obj = d1.getClass(); //使用getDeclaredMethod()获取所有方法 Method[] methods = obj.getDeclaredMethods(); //获取方法的名称 for(Method m : methods) { System.out.println(\u0026#34;方法名称： \u0026#34; + m.getName()); //获取方法的访问修饰符 int modifier = m.getModifiers(); System.out.println(\u0026#34;修饰符： \u0026#34; + Modifier.toString(modifier)); //获取方法的返回类型 System.out.println(\u0026#34;Return Types: \u0026#34; + m.getReturnType()); System.out.println(\u0026#34; \u0026#34;); } } catch(Exception e) { e.printStackTrace(); } } } Java 反射与构造函数 我们还可以使用Constructor类提供的各种方法检查类的不同构造函数。\ngetConstructors() - 返回该类的所有公共构造函数以及该类的超类 getDeclaredConstructor() -返回所有构造函数 getName() - 返回构造函数的名称 getModifiers() - 以整数形式返回构造函数的访问修饰符 getParameterCount() - 返回构造函数的参数数量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Dog { public Dog() { } public Dog(int age) { } private Dog(String sound, String type) { } } class ReflectionDemo { public static void main(String[] args) { try { Dog d1 = new Dog(); Class obj = d1.getClass(); //使用getDeclaredConstructor()获取一个类中的所有构造函数 Constructor[] constructors = obj.getDeclaredConstructors(); for(Constructor c : constructors) { //获取构造函数的名称 System.out.println(\u0026#34;构造函数名称： \u0026#34; + c.getName()); //获取构造函数的访问修饰符 int modifier = c.getModifiers(); System.out.println(\u0026#34;修饰符： \u0026#34; + Modifier.toString(modifier)); //获取构造函数中的参数数量 System.out.println(\u0026#34;参数个数： \u0026#34; + c.getParameterCount()); } } catch(Exception e) { e.printStackTrace(); } } } 参考文献\nhttps://www.cainiaojc.com/java/java-reflection.html\n","permalink":"https://train0405.github.io/posts/tech/%E5%8F%8D%E5%B0%84/","summary":"Java 反射(Reflection) 在Java中，反射允许我们在运行时检查和操作类、接口、构造函数、方法和字段。 Java 类名为Class 在学习Java反射之前，我们需要了解一个名为Class的Java类。 Java中有一个名为Class的类，该类在运行时保留有关对象和类的所有信息。 Class对","title":"反射"},{"content":" Java8概述 Java8 (又称 JKD1.8) 是 Java 语言开发的一个主要版本。 Oracle公司于2014年3月18日发布Java8 。\n支持Lambda表达式 函数式接口 新的Stream API 新的日期 API 其他特性 Lambda表达式 Lambda表达式是特殊的匿名内部类，语法更简洁。\nLambda表达式允许把函数作为一个方法的参数（函数作为方法参数传递），将代码像数据一样传递。\n1 2 3 4 @FunctionalInterface public interface MyInterface { void show(); } 1 2 3 4 5 6 public static void main(String[] args) { MyInterface my = ()-\u0026gt;{ System.out.println(\u0026#34;hello\u0026#34;); }; my.show(); } Comparator接口的Lambda表达式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) { //右边有泛型，Lambda参数列表的泛型可以省略, //如果执行语句只有一句，且无返回值，{}可以省略，若有返回值，则若想省去{}，则必须同时省略return，且执行语句也保证只有一句。]() Comparator\u0026lt;Integer\u0026gt; comparator = new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { return 0; } }; //=============================== // Comparator\u0026lt;Integer\u0026gt; comparator2 = (o1,o2)-\u0026gt; o1-o2; } 函数式接口 ** 概念**\n如果一个接口只有一个抽象方法，则该接口称之为函数式接口。 函数式接口可以使用Lambda表达式，Lambda表达式会被匹配到这个抽象方法上 。 @FunctionalInterface 注解检测接口是否符合函数式接口规范。 常见函数式接口\n接口 参数类型 返回类型 说明 Consumer\u0026lt; T \u0026gt; 消费型接口 T void void accept(T t);对类型为T的对象应用操作 Supplier\u0026lt; T \u0026gt; 供给型接口 无 T T get(); 返回类型为T的对象 Function\u0026lt; T,R \u0026gt; 函数型接口 T R R apply(T t);对类型为T的对象应用操作，并返回类型为R类型的对象。 Predicate\u0026lt; T \u0026gt; 断言型接口 T boolean boolean test(T t);确定类型为T的对象是否满足条件，并返回boolean类型。 Consumer\u0026lt; T \u0026gt; 消费型接口案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main(String[] args) { Consumer\u0026lt;Double\u0026gt; c = new Consumer\u0026lt;Double\u0026gt;() { @Override public void accept(Double aDouble) { } }; //Lambda表达式简化代码 happy(((money)-\u0026gt; System.out.println(money)),500); } public static void happy(Consumer\u0026lt;Double\u0026gt; consumer,double money){ consumer.accept(money); } Supplier\u0026lt; T \u0026gt; 供给型接口案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) { int[] nums = getNums(()-\u0026gt; new Random().nextInt(100), 5); System.out.println(Arrays.toString(nums)); } public static int[] getNums(Supplier\u0026lt;Integer\u0026gt; supplier, int count){ int[] arr = new int[count]; //返回数据，数据怎么实现交给实现类。 for (int i=0;i\u0026lt;count;i++){ Integer integer = supplier.get(); arr[i]=integer; } return arr; } Function\u0026lt; T,R \u0026gt; 函数型接口案例\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) { Integer integer = handlerString((string) -\u0026gt; Integer.valueOf(string), \u0026#34;12345\u0026#34;); System.out.println(integer); } public static Integer handlerString(Function\u0026lt;String,Integer\u0026gt; function, String str){ //Function\u0026lt;T,R\u0026gt; t输入类型，r结果类型 //字符串转Integer类型 return function.apply(str); } Predicate\u0026lt; T \u0026gt; 断言型接口案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;zhangfei\u0026#34;); list.add(\u0026#34;zhangliao\u0026#34;); list.add(\u0026#34;zhanghe\u0026#34;); list.add(\u0026#34;zhaozilong\u0026#34;); List\u0026lt;String\u0026gt; list1 = filterNames(s-\u0026gt;s.startsWith(\u0026#34;zhang\u0026#34;) ,list); System.out.println(list1); //[zhangfei, zhangliao, zhanghe] } public static List\u0026lt;String\u0026gt; filterNames(Predicate\u0026lt;String\u0026gt; predicate,List\u0026lt;String\u0026gt; list){ List\u0026lt;String\u0026gt; newList = new ArrayList\u0026lt;\u0026gt;(); for (String s:list){ if (predicate.test(s)){ newList.add(s); } } return newList; } Java 8 方法引用 方法引用通过方法的名字来指向一个方法。\n方法引用可以使语言的构造更紧凑简洁，减少冗余代码。\n方法引用使用一对冒号 :: 。\n从一个数字列表中找出最大的一个数字，方法引用方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void main(String[] args) { //原始方式找最大值 // Function\u0026lt;List\u0026lt;Integer\u0026gt;, Integer\u0026gt; function = new Function\u0026lt;List\u0026lt;Integer\u0026gt;, Integer\u0026gt;() { // @Override // public Integer apply(List\u0026lt;Integer\u0026gt; integers) { // return Collections.max(integers); // } // }; //lambda方式 Function\u0026lt;List\u0026lt;Integer\u0026gt;, Integer\u0026gt; function = (integers)-\u0026gt;Collections.max(integers); //方法引用 Function\u0026lt;List\u0026lt;Integer\u0026gt;, Integer\u0026gt; f2 = Collections::max; Integer apply = f2.apply(Arrays.asList(1, 10, 3, 5)); System.out.println(apply); } 不同类型的方法引用 有四种方法引用:\n种类 语法 例子 静态方法引用 ContainingClass::staticMethodName Math::abs 特定对象的实例方法引用 containingObject::instanceMethodName this::equals 实例方法的任意一个特定类型的对象引用 ```ContainingClass::staticMethodName` String::concat 构造器引用 ClassName::new HashSet::new 对象::实例方法\n我们可以把一个实例的非静态方法作为Lambda体，比如这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @FunctionalInterface interface TestInterface { String handleString(String a, String b); } class TestClass { public String concatString(String a, String b) { return a + b; } } public class TestDemo { public static void main(String[] args) { TestClass testClass = new TestClass(); TestInterface testInterface = (String a, String b)-\u0026gt; testClass.concatString(a,b); TestInterface testInterface2 = testClass::concatString; System.out.println(testInterface2.handleString(\u0026#34;abc\u0026#34;,\u0026#34;ABC\u0026#34;)); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Demo4 { public static void main(String[] args) { //1 对象::实例方法 Consumer\u0026lt;String\u0026gt; consumer=s-\u0026gt;System.out.println(s); consumer.accept(\u0026#34;hello\u0026#34;); Consumer\u0026lt;String\u0026gt; consumer2=System.out::println; consumer.accept(\u0026#34;world\u0026#34;); //2类::静态方法 Comparator\u0026lt;Integer\u0026gt; com=(o1,o2)-\u0026gt;Integer.compare(o1, o2); Comparator\u0026lt;Integer\u0026gt; com2=Integer::compare; //3类::实例方法 Function\u0026lt;Employee, String\u0026gt; function=e-\u0026gt;e.getName(); Function\u0026lt;Employee, String\u0026gt; function2=Employee::getName; System.out.println(function2.apply(new Employee(\u0026#34;小明\u0026#34;, 50000))); //4类::new Supplier\u0026lt;Employee\u0026gt; supplier=()-\u0026gt;new Employee(); Supplier\u0026lt;Employee\u0026gt; supplier2=Employee::new; Employee employee=supplier.get(); System.out.println(employee.toString()); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class Employee { private String name; private double money; public Employee() { // TODO Auto-generated constructor stub } public Employee(String name, double money) { super(); this.name = name; this.money = money; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getMoney() { return money; } public void setMoney(double money) { this.money = money; } @Override public String toString() { return \u0026#34;Employee [name=\u0026#34; + name + \u0026#34;, money=\u0026#34; + money + \u0026#34;]\u0026#34;; } @Override public int hashCode() { final int prime = 31; int result = 1; long temp; temp = Double.doubleToLongBits(money); result = prime * result + (int) (temp ^ (temp \u0026gt;\u0026gt;\u0026gt; 32)); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Employee other = (Employee) obj; if (Double.doubleToLongBits(money) != Double.doubleToLongBits(other.money)) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } 什么是Stream 流（Stream）与集合类似，但集合中保存的是数据，而Stream中保存对集合或数组数据的操作\nStream特点\nStream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的，会等到需要结果的时候才执行。 Steam的创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;apple\u0026#34;); list.add(\u0026#34;huawei\u0026#34;); list.add(\u0026#34;xiaomi\u0026#34;); //获取Stream流方式一 Stream\u0026lt;String\u0026gt; stream = list.stream(); //获取Stream流方式二 Stream\u0026lt;String\u0026gt; stream2 = list.parallelStream(); stream2.forEach( System.out::println); //获取Stream流方式三 String[] arr = {\u0026#34;aaa\u0026#34;,\u0026#34;bbb\u0026#34;,\u0026#34;ccc\u0026#34;}; Stream\u0026lt;String\u0026gt; stream3 = Arrays.stream(arr); stream3.forEach(System.out::println); //通过Stream接口的of()、iterate()、generate()方法。。 Stream\u0026lt;Integer\u0026gt; integerStream = Stream.of(1, 2, 3, 4, 5); integerStream.forEach(System.out::println); Stream\u0026lt;Integer\u0026gt; iterate =Stream.iterate(10,integer -\u0026gt; integer+2); iterate.limit(5).forEach(System.out::println); Stream\u0026lt;Integer\u0026gt; generate = Stream.generate(()-\u0026gt;new Random().nextInt(100)); generate.limit(10).forEach(System.out::println); //通过IntStream、LongStream、DoubleStream接口中的of、range、rangeClosed方法。 IntStream stream4 = IntStream.of(100,200,300); stream4.forEach(System.out::println); IntStream range = IntStream.rangeClosed(0, 50); range.forEach(System.out::println); } Map集合获取流的方式\n1 2 3 Map\u0026lt;String,String\u0026gt; maps = new HashMap(); Stream\u0026lt;Map.Entry\u0026lt;String, String\u0026gt;\u0026gt; EntryStream = maps.entrySet().stream(); //maps.keySet().stream() maps.values().stream() 数组获取流的方式\n1 Arrays.stream(arr[]); 中间操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public static void main(String[] args) { List\u0026lt;Employee\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new Employee(\u0026#34;张三\u0026#34;,1500)); list.add(new Employee(\u0026#34;李四\u0026#34;,1700)); list.add(new Employee(\u0026#34;赵二\u0026#34;,1000)); list.add(new Employee(\u0026#34;周一\u0026#34;,1200)); list.add(new Employee(\u0026#34;王五\u0026#34;,3500)); list.add(new Employee(\u0026#34;刘六\u0026#34;,2500)); list.add(new Employee(\u0026#34;孙七\u0026#34;,4500)); list.add(new Employee(\u0026#34;孙七\u0026#34;,4500)); list.add(new Employee(\u0026#34;孙七\u0026#34;,4500)); // Stream\u0026lt;Employee\u0026gt; stream = list.stream(); //filter //limit // Stream\u0026lt;Employee\u0026gt; employeeStream = stream.filter(employee -\u0026gt; employee.getMoney() \u0026gt; 1500); // employeeStream.limit(4).skip(2).forEach(System.out::println); Stream\u0026lt;Employee\u0026gt; employeeStream = stream.filter(employee -\u0026gt; employee.getMoney() \u0026gt; 1500); employeeStream.distinct().sorted((e1,e2)-\u0026gt;Double.compare(e1.getMoney(), e2.getMoney())).forEach(System.out::println); //map list.stream().distinct().map(new Function\u0026lt;Employee, Double\u0026gt;() { @Override public Double apply(Employee employee) { return employee.getMoney(); } }).forEach(System.out::print); //1500.0 1700.0 1000.0 1200.0 3500.0 2500.0 4500.0 } 终止操作\n注意：终结操作方法，调用完成后就无法继续使用，原因是不会返回Stream了\n常见终止操作：\nforEach、min、max、count reduce、collect collect：收集stream流，指定收集器，Collectors工具类提供了收集的方式\n1 2 3 Collectors.toList() Collectors.toSet() Collectors.toMap(Function key,Function value) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public static void main(String[] args) { List\u0026lt;Employee\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new Employee(\u0026#34;张三\u0026#34;,1500)); list.add(new Employee(\u0026#34;李四\u0026#34;,1700)); list.add(new Employee(\u0026#34;赵二\u0026#34;,1000)); list.add(new Employee(\u0026#34;周一\u0026#34;,1200)); list.add(new Employee(\u0026#34;王五\u0026#34;,3500)); list.add(new Employee(\u0026#34;刘六\u0026#34;,2500)); list.add(new Employee(\u0026#34;孙七\u0026#34;,4500)); list.add(new Employee(\u0026#34;孙七\u0026#34;,4500)); list.add(new Employee(\u0026#34;孙七\u0026#34;,4500)); //min、max、count Optional\u0026lt;Employee\u0026gt; min = list.stream().min((o1, o2) -\u0026gt; (int) (o1.getMoney() - o2.getMoney())); System.out.println(min); Optional\u0026lt;Employee\u0026gt; max = list.stream().max((o1, o2) -\u0026gt; (int) (o1.getMoney() - o2.getMoney())); System.out.println(max); long count = list.stream().count(); System.out.println(count); //reduce、collect //计算所有员工工资和，先映射工资到map Optional\u0026lt;Double\u0026gt; reduce = list.stream().map((employee) -\u0026gt; employee.getMoney()).reduce((x, y) -\u0026gt; x + y); System.out.println(reduce.get()); //collect 收集指定数据到指定集合 set list Set\u0026lt;String\u0026gt; collect = list.stream().map(employee -\u0026gt; employee.getName()).collect(Collectors.toSet()); System.out.println(collect); } 练习案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 静态变量，所有类对象共享的 public static double allMoney = 0; public static void main(String[] args) { List\u0026lt;Employee\u0026gt; employeeList1 = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Employee\u0026gt; employeeList2 = new ArrayList\u0026lt;\u0026gt;(); employeeList1.add(new Employee(\u0026#34;猪八戒\u0026#34;,8000,800,\u0026#34;偷吃\u0026#34;,\u0026#39;男\u0026#39;)); employeeList1.add(new Employee(\u0026#34;孙悟空\u0026#34;,10000,1500,\u0026#34;顶撞上司\u0026#34;,\u0026#39;男\u0026#39;)); employeeList1.add(new Employee(\u0026#34;沙僧\u0026#34;,6000,700,null,\u0026#39;男\u0026#39;)); employeeList1.add(new Employee(\u0026#34;小白龙\u0026#34;,5000,500,null,\u0026#39;女\u0026#39;)); employeeList2.add(new Employee(\u0026#34;林黛玉\u0026#34;,7000,600,\u0026#34;不加班\u0026#34;,\u0026#39;女\u0026#39;)); employeeList2.add(new Employee(\u0026#34;薛宝钗\u0026#34;,7200,10000,null,\u0026#39;女\u0026#39;)); employeeList2.add(new Employee(\u0026#34;贾宝玉\u0026#34;,9000,900,\u0026#34;贪玩\u0026#34;,\u0026#39;男\u0026#39;)); employeeList2.add(new Employee(\u0026#34;史湘云\u0026#34;,6700,670,null,\u0026#39;女\u0026#39;)); employeeList2.add(new Employee(\u0026#34;王熙凤\u0026#34;,11000,800,\u0026#34;贪污\u0026#34;,\u0026#39;女\u0026#39;)); //分别找出2个部门最高工资的员工信息,封装成优秀员工Topperformer Optional\u0026lt;Topperformer\u0026gt; topperformer1 = employeeList1.stream(). max((emp1, emp2) -\u0026gt; (int) ((emp1.getSalary() + emp1.getBonus()) - (emp2.getSalary() + emp2.getBonus()))) .map(employee -\u0026gt; new Topperformer(employee.getName(), employee.getSalary() + employee.getBonus())); Optional\u0026lt;Topperformer\u0026gt; topperformer2 = employeeList2.stream(). max((emp1, emp2) -\u0026gt; (int) ((emp1.getSalary() + emp1.getBonus()) - (emp2.getSalary() + emp2.getBonus()))). map(employee -\u0026gt; new Topperformer(employee.getName(), employee.getSalary() + employee.getBonus())); System.out.println(topperformer1); System.out.println(topperformer2); //分别求出两个部门的平均月收入，去掉最高工资和最低工资 employeeList1.stream().sorted((emp1, emp2) -\u0026gt; (int) ((emp1.getSalary() + emp1.getBonus()) - (emp2.getSalary() + emp2.getBonus()))) .skip(1).limit(employeeList1.size()-2).forEach(employee -\u0026gt; { double money = employee.getBonus()+employee.getSalary(); allMoney +=money; }); System.out.println(\u0026#34;开发一部的平均工资是 \u0026#34;+(allMoney/(employeeList1.size()-2))); } ","permalink":"https://train0405.github.io/posts/tech/java8%E6%96%B0%E7%89%B9%E6%80%A7/","summary":"Java8概述 Java8 (又称 JKD1.8) 是 Java 语言开发的一个主要版本。 Oracle公司于2014年3月18日发布Java8 。 支持Lambda表达式 函数式接口 新的Stream API 新的日期 API 其他特性 Lambda表达式 Lambda表达式是特殊的匿名内部类，语法更简洁。 Lambda表达式允许把函数作为一个方","title":"Java8新特性"},{"content":" IO流的分类 按方向\n输入流：将文件中的内容读入到java中。\n输出流：将java中的内容写入到文件中。\n按单位\n字节流：以字节为单位，可以读写所有数据 。\n字符流：以字符为单位，只能读写文本数据 。\n按功能\n节点流：具有实际传输数据的读写功能。\n处理流：在节点流的基础之上增强功能。\njava.io包下的流类型非常多，容易混淆，但是要始终记住，java的I/O处在4大基类，而所有的IO流实现类，都是其子类\n输入流 输出流 字节流 InputStream 字节输入流 OutputStream 字节输出流 字符流 Reader 字符输入流 Writer 字符输出流 各自的子类，都以父类作为自己的后缀，比如文件的字节输出流，FileOutputStream,文件的字符输入流FileReader\n操作流，记住六字箴言\n读进去：进来，说明使用输入流，读是输入流中的一个方法(read)\n写出来：出去，说明使用输出流，写是输出流中的一个方法(write)\nI/O流架构体系 节点流\u0026ndash;直接连接数据源的流 File 文件流。对文件进行读、写操作 ：FileReader、FileWriter、FileInputStream、FileOutputStream。\n从/向内存数组读写数据: CharArrayReader与 CharArrayWriter、ByteArrayInputStream与ByteArrayOutputStream。\n从/向内存字符串读写数据 StringReader、StringWriter、StringBufferInputStream。\nPipe管道流。 实现管道的输入和输出（进程间通信）: PipedReader与PipedWriter、PipedInputStream与PipedOutputStream。\n处理流\u0026ndash;连接已存在的流 Buffering缓冲流：在读入或写出时，对数据进行缓存，以减少I/O的次数：BufferedReader与BufferedWriter、BufferedInputStream与BufferedOutputStream。\nFiltering 滤流：在数据进行读或写时进行过滤：FilterReader与FilterWriter、FilterInputStream与FilterOutputStream。\nConverting between Bytes and Characters 转换流：按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换（Stream到Reader）：InputStreamReader、OutputStreamWriter。\nObject Serialization 对象流 ：ObjectInputStream、ObjectOutputStream。\nDataConversion数据流： 按基本数据类型读、写（处理的数据是Java的基本类型（如布尔型，字节，整数和浮点数））：DataInputStream、DataOutputStream 。\nCounting计数流： 在读入数据时对行记数 ：LineNumberReader、LineNumberInputStream。\nPeeking Ahead预读流： 通过缓存机制，进行预读 ：PushbackReader、PushbackInputStream。 8 .Printing打印流： 包含方便的打印方法 ：PrintWriter、PrintStream。\nFileInputStream \u0026amp; FileOutputStream 实现文件拷贝的案例 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) throws Exception { //使用文件字节流 一次拷贝一个字节数组 byte[] b = new byte[1024]; //相对路径 FileInputStream fis = new FileInputStream(\u0026#34;1.png\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;2.png\u0026#34;); int len = 0; while((len=fis.read(b)) != -1 ){ fos.write(b,0,len); } fis.close(); fos.close(); } DataInputStream \u0026amp; DataOutputStream DataInputStream \u0026amp; DataOutputStream，是处理流，改构造方法接收一个已存在的输入输出流， 允许程序从读取方便快捷 操作java的基本数据类型。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void main(String[] args) throws Exception { //读写java的基本数据类型。 FileInputStream is = new FileInputStream(\u0026#34;2.txt\u0026#34;); FileOutputStream os = new FileOutputStream(\u0026#34;2.txt\u0026#34;); //写到2.txt DataOutputStream dos = new DataOutputStream(os); dos.writeInt(20); dos.writeChar(\u0026#39;J\u0026#39;); dos.writeBoolean(false); dos.close(); //从1.txt读进来 DataInputStream dis = new DataInputStream(is); int i = dis.readInt(); char c = dis.readChar(); boolean b = dis.readBoolean(); System.out.println(i); System.out.println(c); System.out.println(b); dis.close(); } BufferedInputStream \u0026amp; BufferedOutputStream BufferedInputStream \u0026amp; BufferedOutputStream 为另一个输入输出流流添加一些功能，即缓冲区的作用。在创建 BufferedInputStream \u0026amp; BufferedOutputStream 时，会创建一个内部缓冲区数组。\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) throws IOException { //为文件字节流 添加缓冲区功能， 一次读写一个字节数组数据，但内部缓冲区数组已经填满 byte[] b = new byte[1024]; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\u0026#34;1.png\u0026#34;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\u0026#34;3.png\u0026#34;)); int len = 0; while((len = bis.read(b)) != -1){ bos.write(b,0,len); } bis.close(); bos.close(); } PrintStream PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。 1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) throws FileNotFoundException { PrintStream ps = new PrintStream(\u0026#34;test.txt\u0026#34;); ps.println(5); ps.print(\u0026#34;Aaaa\u0026#34;); ps.print(false); ps.println(\u0026#34;hahah\u0026#34;); ps.flush(); ps.close(); } InputStreamReader \u0026amp; OutputStreamWriter java 在jdk1.1种提供了，针对字符处理的 方便类,字符流，将原来的字节流，增加了 字符编码表 编码处理功能\n字节流到字符流的转换流，read（）和writer（）方法会一次输入输出多个字节，以包装字符转换有效，\n字节流 + 编码表 = InputStreamReader \u0026amp; OutputStreamWriter\nFileReader \u0026amp; FileWriter 在只针对将字符写入文件的时候，因为 每次使用 转换流，对字节流进行包装，写法太麻烦，所以jdk 提供了 字节转换流子类FileReader \u0026amp; FileWriter，方便的进行字符文件的IO操作\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) throws IOException { //使用 字符转换流， 实现文本文件的 拷贝 FileReader fr = new FileReader(\u0026#34;1.txt\u0026#34;); FileWriter fw = new FileWriter(\u0026#34;8.txt\u0026#34;); char[] chars = new char[1024]; int len = 0; while ((len = fr.read(chars)) != -1){ fw.write(chars,0,len); } fr.close(); fw.close(); } StringReader \u0026amp; StringWriter 方便快捷的将字符串写入内存，或从内存读取\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) throws IOException, NoSuchFieldException { //1. 向内存写入数据，其内部提供了一个缓冲区 StringWriter writer = new StringWriter(); writer.write(\u0026#34;hello world\u0026#34;); //2. 读取数据 StringReader reader = new StringReader(writer.toString()); char[] data = new char[1024]; int len = reader.read(data); System.out.println(new String(data,0,len)); } 本文参考：https://juejin.cn/post/6844903910348603405\n","permalink":"https://train0405.github.io/posts/tech/io/","summary":"IO流的分类 按方向 输入流：将文件中的内容读入到java中。 输出流：将java中的内容写入到文件中。 按单位 字节流：以字节为单位，可以读写所有数据 。 字符流：以字符为单位，只能读写文本数据 。 按功能 节点流：具有实际传输数据的读写功能。 处理流：在节点流的基础之上增强功能。 java.io包下","title":"IO"},{"content":" Throwable Throwable 类是 Java 语言中所有错误或异常的超类。\n只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型。\njava定义了一个Throwable类作为所有异常类的超类。java中定义了很多异常类，\n主要分为两类：Error和Exception\nError\nError 是 Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。\n当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误，都是一些比较严重的问题，大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM出现的问题，如OutOfMemoryError、StackOverFlowError等，这些异常发生时，JVM一般会选则终止。error表明系统JVM已经处于不可恢复的崩溃状态。\nJava 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。\nException\nException 异常主要分为两类\n检查异常：CheckedException:所有不是RuntimeException的异常，统称为CheckedException，它强迫程序员处理异常，大大增强程序的可靠性。如IoException、SQLException等以及用户自定义的Exception异常，这类异常在编译时就必须做出处理，否则无法通过编译。\n运行时异常（unchecked 异常（非检查型异常））：RuntimeException：这类异常通常是由编程错误导致的，所以在编写程序时，并不要求必须使用异常处理机制处理这类异常，而是经常需要通过增加“逻辑处理来避免这些异常”。\nError和Exception的区别 Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程；\nException通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。\n其中检查异常是必须要处理的异常，当程序中出现这类异常时，要么使用try/catch捕获，要么使用throws语句向上抛出，否则编译无法通过。\n非检查异常包括运行时异常(RuntimeException)以及error，编译器不要求强制处理，但我们在写代码的时候要考虑到这些情况进行预防。\n自定义异常类型 在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。\n所有异常都必须是 Throwable 的子类。 如果希望写一个检查性异常类，则需要继承 Exception 类。 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Test { public static void main(String[] args) { try { new Input().method(); } catch (WrongInputException e) { System.out.println(e.getMsg()); } } } class Input{ void method() throws WrongInputException{ throw new WrongInputException(\u0026#34;Wrong input\u0026#34;); } } // 自定义异常 继承Exception 检查性异常 class WrongInputException extends Exception{ private String msg; public WrongInputException(String msg){ this.msg = msg; } public String getMsg() { return msg; } } 异常的处理方式 try\u0026hellip;catch关键字\n使用 try 和 catch 关键字可以捕获异常。 try/catch 代码块放在异常可能发生的地方 try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：\n1 2 3 4 5 try { // 程序代码 } catch(ExceptionName e1) { //Catch 块 } Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。\n一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。\n多重捕获块的语法如下所示：\n1 2 3 4 5 6 7 8 9 try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 } throws/throw 关键字 throws：用在方法签名中，用于声明该方法可能抛出的异常。\nthrow:用于抛出异常\nfinally关键字 finally 关键字用来创建在 try 代码块后面执行的代码块。\n无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。\nfinally 代码块出现在 catch 代码块最后，语法如下：\n1 2 3 4 5 6 7 8 9 try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }finally{ // 程序代码 } 本文部分内容参考自\nhttps://www.jianshu.com/p/49d2c3975c56\nhttps://juejin.cn/post/6965515719454752781\n","permalink":"https://train0405.github.io/posts/tech/%E5%BC%82%E5%B8%B8/","summary":"Throwable Throwable 类是 Java 语言中所有错误或异常的超类。 只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型。 java定义了一个Throwable类作为所有异常类的超类。java中定义了很多异常类， 主要分为两类：Erro","title":"异常"},{"content":" Map接口 介绍 ​ Map（也称为字典、关联数组）是用于保存具有映射关系的数据，保存两组值，key和value，这两组值可以是任何应用类型的数据。 Map的key不允许重复（底层Map的keySet()返回的是key的Set集合，所以key不会重复），即Map中对象的任意两个key通过equals()方法得到的都是false。而，Map的value值是可以重复的（Map的底层values()方法返回类型是Collection，可以存储重复元素），通过key总能找到唯一的value，Map中的key组成一个Set集合，所以可以通过keySet()方法返回所有key。Set底层也是通过Map实现的，只不过value都是null的Map来实现的。\nMap实现类\n​ Map典型的实现类是HashMap、Hashtable（HashMap子类还有LinkedHashMap）、SortedMap子接口及实现类TreeMap、WeakHashMap、IndentityHashMap等。\nMap有一个内部类Entry，该类封装了key-value对，将key-value捆绑到一起存放Map.Entry。有如下三个方法：\nK getKey();：获取Entry中的key值；\nV getValue();：获取Entry中的value值；\nV setValue(V value);：设置Entry中的value值，并返回新设置的value值。\nMap常用方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void main(String[] args) { Map map = new HashMap\u0026lt;\u0026gt;(); Map map2 = new HashMap\u0026lt;\u0026gt;(); //向Map添加key-value map.put(1001,\u0026#34;林黛玉\u0026#34;); map.put(1002,\u0026#34;薛宝钗\u0026#34;); map.put(1003,\u0026#34;史湘云\u0026#34;); map.put(1004,\u0026#34;刘姥姥\u0026#34;); System.out.println(map); //获取某个key所对应的value；若不包含该key，则返回null Object value = map.get(1001); System.out.println(value); //移除指定的key所对应的key-value对，若成功删除，则返回移除的value值 Object remove = map.remove(1004); System.out.println(remove); System.out.println(map); //判断该Map中是否包含指定的key。 boolean b = map.containsKey(1002); System.out.println(b); //将指定的Map中的key-value对全部复制到该Map中。 map2.putAll(map); System.out.println(map2); //boolean isEmpty();：判断该Map是否为空。 //int size();：返回Map的key-value对的长度 //void clear();：清除Map中的所有key-value对。 //boolean remove(Object key, Object value)：删除指定的key-value对，若删除成功，则返回true；否则，返回false } Map的遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public static void main(String[] args) { Map\u0026lt;Integer,String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1001,\u0026#34;林黛玉\u0026#34;); map.put(1002,\u0026#34;薛宝钗\u0026#34;); map.put(1003,\u0026#34;史湘云\u0026#34;); //遍历Map中所有的entry == 遍历Map中的所有的key 和 value //entrySet()返回该Map中Entry类的Set集合 Set\u0026lt;Map.Entry\u0026lt;Integer, String\u0026gt;\u0026gt; entries = map.entrySet(); for(Map.Entry entry:entries){ System.out.println(entry.getKey()+\u0026#34;=\u0026#34;+entry.getValue()); } System.out.println(\u0026#34;========\u0026#34;); //使用迭代器遍历 Iterator\u0026lt;Map.Entry\u0026lt;Integer, String\u0026gt;\u0026gt; iterator = entries.iterator(); while (iterator.hasNext()){ Map.Entry\u0026lt;Integer, String\u0026gt; next = iterator.next(); System.out.println( next.getKey()+next.getValue()); } System.out.println(\u0026#34;=====\u0026#34;); //遍历key 获取value Set\u0026lt;Integer\u0026gt; integers = map.keySet(); for (Integer integer :integers){ System.out.println(integer+map.get(integer)); } System.out.println(\u0026#34;=====\u0026#34;); //直接获取Map中的所有Value Collection Collection\u0026lt;String\u0026gt; values = map.values(); for (String v :values){ System.out.println(v); } } HashMap HashMap底层是数组+链表的形式，实现Map.Entry接口，数组是Entry[]数组，是一个静态内部类，Entry是key-value键值对，持有一个指向下一个元素的next引用，这就构成链表（单向链表）。 HashMap底层是数组和链表的结合体。底层是一个线性数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。数组是Entry[]数组，静态内部类。Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用next，这就构成了链表。根据指定的hash值找到在table中的索引；HashMap底层数组的长度是2^n，默认是16,负载因子为0.75，所以最大容量阈值threshold = (int)(capacity * loadFactor);16*0.75=12，当超过这个阈值的时候，开始扩容，即每次扩容增加一倍。\nput实现原理\n当我们往HashMap中put元素的时候：当程序试图将一个key-value对放入HashMap中时，\n程序首先根据该 key 的hashCode() 返回值，决定该 Entry 的存储位置； 若Entry的存储位置上为null，直接存储该对象；若不为空，两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。 循环遍历链表，如果这两个 Entry 的 key 通过equals() 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的value，但key不会覆盖；如果这两个 Entry 的 key 通过equals()比较返回 false，将该对象放到数组中，然后将数组中原有的Entry对象链接到此对象后面。新添加的 Entry 将与集合中原有 Entry 形成Entry 链，而且新添加的Entry位于 Entry 链的头部 get实现原理\n从HashMap中get元素时，\n首先计算key的hash值，通过hash函数，找到数组中对应位置的某一元素； 然后通过key的equals()方法（key同不同）在对应位置的链表中找到需要的元素。 TreeMap ​ TreeMap是SortedMap接口的实现类，TreeMap底层是红黑树数据结构，每个key-value作为红黑树的一个节点。TreeMap存储节点时，根据key对节点进行排序，主要是自然排序和自定义排序。类似于TreeSet\nHashtable ​ Hashtable是和HashMap一样，属于Map典型的实现类，区别于HashMap的是，Hashtable是线程安全的Map实现，但是性能低。Hashtable不允许使用null作为key和value；若将null值存入Hashtable，会抛出NullPointerException异常；而HashMap可以使用null作为key或value。\nLinkedHashMap ​ LinkedHashMap是HashMap的子类，使用双向链表维护key-value对的顺序（只是关注key的顺序），迭代顺序和key-value插入Map中的顺序保持一致。\n本文参考自 https://juejin.cn/post/6844904118310404103\n","permalink":"https://train0405.github.io/posts/tech/map%E9%9B%86%E5%90%88/","summary":"Map接口 介绍 ​ Map（也称为字典、关联数组）是用于保存具有映射关系的数据，保存两组值，key和value，这两组值可以是任何应用类型的数据。 Map的key不允许重复（底层Map的keySet()返回的是key的Set集合，所以key不会重复），即Map中对象的任意两个key通过","title":"Map集合"},{"content":" 集合 对象数组的概述和使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //需求: 创建5个学生对象, 将对象存入到数组中,遍历数组,打印学生信息 public static void main(String[] args) { Student[] sts = new Student[5]; sts[0] = new Student(\u0026#34;小红\u0026#34;, 18); sts[1] = new Student(\u0026#34;小明\u0026#34;, 19); sts[2] = new Student(\u0026#34;小白\u0026#34;, 20); sts[3] = new Student(\u0026#34;小辉\u0026#34;, 21); sts[4] = new Student(\u0026#34;小张\u0026#34;, 23); for (int i = 0; i \u0026lt; sts.length; i++) { System.out.println(sts[i]); } } //解析 //* 数组中存放的是对象的地址值 //* 遍历数组时就可以拿到引用地址值,调用对象完成方法 集合概述 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 概述 我们都知道,数组的长度是不可变的, 当元素的个数超过数组的长度之后, 我们就只能通过创建长度更长的新数组的方式来存储元素, 太麻烦了 集合给我提供另外一种容器的概念,可变长度的容器, 这样,程序在使用的时候就不需要再考虑容器容量的问题,从而可以更加专心于业务 我们要知道,java中数组是唯一的底层容器,所有, 集合是开发者使用java规范制作的逻辑上的容器 数组和集合的区别 区别1 数组既可以存储基本数据类型, 又可以储存引用数据类型,基本数据类型存储的是值, 引用数据类型储存的是地址值 集合只能存储引用数据类型(对象的引用), 其实集合也可以存储基本数据类型, 但是在存储的时候自动装箱变成包装类对象 区别2 数组长度是固定的,不能自动增长 集合的长度的是可变的,可以根据元素的增加而增长 使用场景 如果元素的个数是固定的,推荐使用数组 如果元素的个数不固定,推荐使用集合(日常开发中,使用集合比较普遍) 集合分类 Collection集合 单列集合, 直接存储对象的引用 Map集合 双列集合, 使用key-value的形式, 每个元素会有一个唯一的名称 Collection 主要关注3个子接口\nList: 有序(存入的顺序和内存中存储的顺序是相同的)，可存放重复元素\nSet: 无序，不可存放重复元素\nQueue，先进先出\nList list集合的实现类主要关注三个，如图\nArrayList 底层是数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void main(String[] args) { List list = new ArrayList\u0026lt;\u0026gt;(); //ArrayList的增删改查 list.add(\u0026#34;林黛玉\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); list.add(1,\u0026#34;史湘云\u0026#34;); System.out.println(list); List list1 = new ArrayList(); list1.add(\u0026#34;贾宝玉\u0026#34;); list1.addAll(list); System.out.println(list1); // list1.remove(\u0026#34;贾宝玉\u0026#34;); list1.remove(0); System.out.println(list1); list1.set(0,\u0026#34;刘姥姥\u0026#34;); System.out.println(list1); Object name = list1.get(0); System.out.println(name); } ArrayList的初始化\n构造器\n1 2 public ArrayList()//构造一个初始容量为10的空列表 public ArrayList(int initialCapacity)//构造具有指定初始容量的空列表 new ArrayList\u0026lt;\u0026gt;() 底层数组是否会创建，容量是多少\n1 2 3 4 5 public static void main(String[] args) { List list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); } new ArrayList的时候会调用ArrayList的空参构造方法，执行代码 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; elementData属性用于存放数据。 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 默认情况下是一个空元素数组。 也就是说this.elementData 是一个空数组。\n关注点来到list.add(1)，点进ArrayList源码查看add()，源码如下\n1 2 3 4 5 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } size：表示当前ArrayList的长度(包含元素的数量) 默认值是0。\n下面来看 ensureCapacityInternal(size + 1)；这行代码做了什么事情。\n1 2 3 4 5 6 7 8 9 10 11 12 13 //minCapacity是size+1 = 1 private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } //方法里面调用了calculateCapacity(elementData, minCapacity)这个方法翻译过来就是计算容量，第一次的话是把空数组和容量是1的参数传进来。源码进去看看 private static int calculateCapacity(Object[] elementData, int minCapacity) { //elementData是空的，DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是空，条件成立 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { //返回Math.max(DEFAULT_CAPACITY, minCapacity)之间的较大值 DEFAULT_CAPACITY默认值是10，所以返回他 return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } calculateCapacity 返回值是10，现在可以往回看ensureExplicitCapacity(10)这个方法了，看看他源码干了什么\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private void ensureExplicitCapacity(int minCapacity) { //先不管这个，并发操作的统计，防止并发失败 modCount++; // overflow-conscious code //elementData是空的数组，长度自然是0,所以条件成立 if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } //gorw方法源码 private void grow(int minCapacity) { // overflow-conscious code //oldCapacity是0 int oldCapacity = elementData.length; //oldCapacity右移1位，就是除以2，所以newCapacity也是0 int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); //条件成立 if (newCapacity - minCapacity \u0026lt; 0) //把10赋予newCapacity newCapacity = minCapacity; //MAX_ARRAY_SIZE是一个很大很大的之，条件不成立 if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //给elementData数组赋值 elementData = Arrays.copyOf(elementData, newCapacity); } 也就是说在第一次 add(1)的时候最终执行的是，这一行代码\nelementData = Arrays.copyOf(elementData, newCapacity);\n结论就是：在第一次执行add方法的时候，会给elementData赋一个容量为10的新数组，在新数组中添加元素\nIterator iterator不是一个集合，他是一个用于访问集合的方法，可以用于迭代ArrayList集合。\n迭代器 it 的两个基本操作是 next 、hasNext 和 remove。\n调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。\n调用 it.hasNext() 用于检测集合中是否还有元素。\n调用 it.remove() 将迭代器返回的元素删除。\n获取一个迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public static void main(String[] args) { List list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;林黛玉\u0026#34;); list.add(\u0026#34;史湘云\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); //获取迭代器 Iterator iterator = list.iterator(); //iterator 一开始指向前面位置 while (iterator.hasNext()) { String s = (String) iterator.next(); if (s.equals(\u0026#34;史湘云\u0026#34;)) { iterator.remove(); } else { System.out.println(s); } } } public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(7); list.add(11); list.add(12); //删除少于10的元素 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()){ if(it.next() \u0026lt; 10){ it.remove(); } } System.out.println(list); } LinkedList 底层是双向链表，链表是一种常见的数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。\n链表可分为单向链表和双向链表。\n一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。\n一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。\nJava LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。\n与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。\n以下情况使用 ArrayList :\n​ 频繁访问列表中的某一个元素。\n​ 只需要在列表末尾进行添加和删除元素操作\n以下情况使用 LinkedList :\n​ 你需要通过循环迭代来访问列表中的某些元素。\n​ 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。\nLinkedList 继承了 AbstractSequentialList 类。\nLinkedList 实现了 Queue 接口，可作为队列使用。\nLinkedList 实现了 List 接口，可进行列表的相关操作。\nLinkedList 实现了 Deque 接口，可作为队列使用。\nLinkedList 实现了 Cloneable 接口，可实现克隆。\nLinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。\n简单的链表实例\n1 2 3 4 5 6 7 8 9 LinkedList list = new LinkedList(); list.add(\u0026#34;林黛玉\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); list.add(\u0026#34;史湘云\u0026#34;); System.out.println(list); //输出结果 [林黛玉, 薛宝钗, 薛宝钗, 史湘云] 更多的情况下我们使用 ArrayList 访问列表中的随机元素更加高效，但以下几种情况 LinkedList 提供了更高效的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static void main(String[] args) { LinkedList list = new LinkedList(); list.add(\u0026#34;林黛玉\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); list.add(\u0026#34;史湘云\u0026#34;); //列表的开头添加元素 list.addFirst(\u0026#34;刘姥姥\u0026#34;); //在列表的结尾添加元素 list.addLast(\u0026#34;王熙凤\u0026#34;); System.out.println(list); //在列表的开头移除元素 list.removeFirst(); //在列表的结尾移除元素 list.removeLast(); System.out.println(list); //获取列表开头的元素 Object first = list.getFirst(); System.out.println(first); //获取列表结尾的元素 Object last = list.getLast(); System.out.println(last); } Vector Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：\n​ Vector 是同步访问的。\n​ Vector 包含了许多传统的方法，这些方法不属于集合框架。\nSet 无序，不重复\n不重复原因：通过hashCode方法和equals方法来保证元素的唯一性，add()返回的是boolean类型\n先判断元素的hashCode值是否一致，一致就判断equals方法，如果存储在HashSet中的两个对象hashCode方法的值相同equals方法返回的结果是true，那么HashSet认为这两个元素是相同元素，只存储一个（重复元素无法存入）。\nHashSet 和ArrayList集合都有判断元素是否相同的方法，\nboolean contains(Object o)\nHashSet使用hashCode和equals方法，ArrayList使用了equals方法\nHashSet HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。\nHashSet 允许有 null 值。\nHashSet 是无序的，即不会记录插入的顺序。\nHashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。\nHashSet 实现了 Set 接口。\nHashSet 中的元素实际上是对象，一些常见的基本类型可以使用它的包装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static void main(String[] args) { HashSet hashSet = new HashSet(); hashSet.add(\u0026#34;林黛玉\u0026#34;); hashSet.add(\u0026#34;薛宝钗\u0026#34;); hashSet.add(\u0026#34;史湘云\u0026#34;); hashSet.add(\u0026#34;王熙凤\u0026#34;); hashSet.add(\u0026#34;王熙凤\u0026#34;); System.out.println(hashSet);//[史湘云, 薛宝钗, 王熙凤, 林黛玉] // 在上面的实例中，王熙凤 被添加了两次，它在集合中也只会出现一次，因为集合中的每个元素都必须是唯一的。 //我们可以使用 contains() 方法来判断元素是否存在于集合当中: boolean b = hashSet.contains(\u0026#34;林黛玉\u0026#34;); System.out.println(b);//true // 删除元素，删除成功返回 true，否则为 false boolean b1 = hashSet.remove(\u0026#34;王熙凤\u0026#34;); System.out.println(b1);//true //iterator遍历 Iterator iterator = hashSet.iterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); } System.out.println(\u0026#34;=====\u0026#34;); //for-each 遍历 for (Object o : hashSet){ System.out.println(o); } } 使用HashSet存储自定义对象，并尝试添加重复对象（对象的重复的判定）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public static void main(String[] args) { HashSet hashSet = new HashSet(); Person person1 = new Person(12,\u0026#34;林黛玉\u0026#34;); Person person2 = new Person(13,\u0026#34;薛宝钗\u0026#34;); Person person3 = new Person(13,\u0026#34;薛宝钗\u0026#34;); hashSet.add(person1); hashSet.add(person2); hashSet.add(person3); for (Object p :hashSet){ System.out.println(p); } } } class Person{ private int age; private String name; public int getAge() { return age; } public Person(int age, String name) { this.age = age; this.name = name; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;age=\u0026#34; + age + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age \u0026amp;\u0026amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(age, name); } TreeSet TreeSet类概述\n​ 使用元素的自然顺序对元素进行排序\n​ 或者根据创建 set 时提供的 Comparator 进行排序\n​ 具体取决于使用的构造方法。\n1 2 3 4 5 构造方法 TreeSet() 构造一个新的，空的树组，根据其元素的自然排序进行排序。 TreeSet(Comparator\u0026lt;? super E\u0026gt; comparator) 构造一个新的，空的树集，根据指定的比较器进行排序。 TreeSet是如何保证元素的排序和唯一性的\n​ 底层数据结构是红黑树(红黑树是一种自平衡的二叉树)\n案例\n1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { TreeSet ts = new TreeSet(); ts.add(\u0026#34;ccc\u0026#34;); ts.add(\u0026#34;aaa\u0026#34;); ts.add(\u0026#34;ddd\u0026#34;); ts.add(\u0026#34;bbb\u0026#34;); ts.add(\u0026#34;bbb\u0026#34;); //[aaa, bbb, ccc, ddd] 不重复，自然顺序排序 System.out.println(ts); } 既然TreeSet可以自然排序,那么TreeSet必定是有排序规则的。\n1:让存入的元素自定义比较规则。\n2:给TreeSet指定排序规则。\n方式一：元素自身具备比较性\n元素自身具备比较性，需要元素实现Comparable接口，重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫做默认排序。比如String\n方式二：容器具备比较性\n当元素自身不具备比较性，或者自身具备的比较性不是所需要的。那么此时可以让容器自身具备。需要定义一个类实现接口Comparator，重写compare方法，并将该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。\n注意：当Comparable比较方式和Comparator比较方式同时存在时，以Comparator的比较方式为主；\nreturn 0来判断唯一性\n比较器接口\n1 2 3 4 ----| Comparable compareTo(Object o) 元素自身具备比较性 ----| Comparator compare( Object o1, Object o2 )\t给容器传入比较器 让元素自身具备比较性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 public class Demo10 { public static void main(String[] args) { TreeSet treeSet = new TreeSet(); treeSet.add(new Person1(15,\u0026#34;林黛玉\u0026#34;)); treeSet.add(new Person1(11,\u0026#34;薛宝钗\u0026#34;)); treeSet.add(new Person1(13,\u0026#34;史湘云\u0026#34;)); treeSet.add(new Person1(12,\u0026#34;袭人\u0026#34;)); System.out.println(treeSet); } } //让元素自身具备比较性 class Person1 implements Comparable{ public Person1(int age, String name) { this.age = age; this.name = name; } private int age; private String name; @Override public int compareTo(Object o) { Person1 p1 = (Person1)o; if(this.age \u0026gt;p1.age){ return 1; } if(this.age \u0026lt; p1.age){ return -1; } return this.name.compareTo(p1.name); } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;Person1{\u0026#34; + \u0026#34;age=\u0026#34; + age + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person1 person1 = (Person1) o; return age == person1.age \u0026amp;\u0026amp; Objects.equals(name, person1.name); } @Override public int hashCode() { return Objects.hash(age, name); } } 让容器自身具备比较性，自定义比较器\n需求：当元素自身不具备比较性，或者元素自身具备的比较性不是所需的。\n那么这时只能让容器自身具备。\n定义一个类实现Comparator 接口，覆盖compare方法。\n并将该接口的子类对象作为参数传递给TreeSet集合的构造函数。\n当Comparable比较方式，及Comparator比较方式同时存在，以Comparator\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 public class Demo13 { public static void main(String[] args) { TreeSet treeSet = new TreeSet(new MyComparator()); treeSet.add(new Computer(\u0026#34;Lenovo\u0026#34;,1000)); treeSet.add(new Computer(\u0026#34;Asus\u0026#34;,6900)); treeSet.add(new Computer(\u0026#34;MacBookPro\u0026#34;,12000)); treeSet.add(new Computer(\u0026#34;MacBookPro\u0026#34;,11000)); treeSet.add(new Computer(\u0026#34;Lenovo\u0026#34;,8900)); treeSet.add(new Computer(\u0026#34;Asus\u0026#34;,6900)); treeSet.add(new Computer(\u0026#34;MacBookPro\u0026#34;,12000)); treeSet.add(new Computer(\u0026#34;Dell\u0026#34;,7900)); System.out.println(treeSet); } } class MyComparator implements Comparator { @Override public int compare(Object o1, Object o2) { Computer computer1 = (Computer) o1; Computer computer2 = (Computer) o2; if(computer1.getName().compareTo(computer2.getName()) \u0026gt; 0){ return 1; } if(computer1.getName().compareTo(computer2.getName()) \u0026lt; 0){ return -1; } if(computer1.getPrice() \u0026gt; computer2.getPrice()){ return 1; } if(computer1.getPrice() \u0026lt; computer2.getPrice()){ return -1; } return 0; } } class Computer{ private String name; private int price; @Override public String toString() { return \u0026#34;Computer{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Computer computer = (Computer) o; return price == computer.price \u0026amp;\u0026amp; Objects.equals(name, computer.name); } @Override public int hashCode() { return Objects.hash(name, price); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public Computer(String name, int price) { this.name = name; this.price = price; } } LinkedHashSet 会保存插入的顺序。\n看到array，就要想到角标。\n看到link，就要想到first，last。\n看到hash，就要想到hashCode,equals.\n看到tree，就要想到两个接口。Comparable，Comparator。\n本文参考自\nhttps://blog.csdn.net/qq_33642117/article/details/52040345\nhttps://www.runoob.com/java/java-hashset.html\n","permalink":"https://train0405.github.io/posts/tech/%E9%9B%86%E5%90%88/","summary":"集合 对象数组的概述和使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //需求: 创建5个学生对象, 将对象存入到数组中,遍历数组,打印学生信息 public static void main(String[] args) { Student[] sts = new Student[5]; sts[0] = new Student(\u0026#34;小红\u0026#34;, 18); sts[1] = new Student(\u0026#34;小明\u0026#34;, 19); sts[2] = new Student(\u0026#3","title":"集合"},{"content":"正则表达式 Pattern(描述正则表达式的规则)\n1 首先将正则表达式（指定为字符串）编译为此类Pattern的实例。 然后将所得的实例可以被用来创建一个Matcher对象可以匹配任意character sequences针对正则表达式。 执行匹配的所有状态都驻留在匹配器中，所以许多匹配者可以共享相同的模式 1 2 3 4 5 6 7 // ab 正则表达式 == 规则 Pattern pattern = Pattern.compile(\u0026#34;ab\u0026#34;); //abb 待匹配的字符串 Matcher matcher = pattern.matcher(\u0026#34;abb\u0026#34;); //匹配字符是否符合正则表达式 boolean b = matcher.matches(); System.out.println(b); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1.字符内容 . 表示1个任意字符 \\d 表示1个数字，注意： 在字符串中要这么写 \\\\d \\D 表示非数字 \\s 表示1个空格 \\S 表示非空格 \\w 表示1个单词字符： a-zA-Z_0-9 \\W 表示非单词字符 a 表示字符a本身 [abc] 表示abc中的某一个 [^abc] 表示非abc中的某一个 [a-p[o-q]] 表示或 [a-p\u0026amp;\u0026amp;[o-q]] 表示与 1 2 3 4 5 6 7 8 9 10 11 12 13 2.字符数量 内容{3} 内容正好出现3次 内容{3,5} 内容出现3到5次都可以 内容{3,} 内容至少出现3次 内容? 内容出现零次或一次 内容* 内容出现零次或多次 内容+ 内容出现一次或多次 1 2 3 4 3.边界匹配器 ^ 行的开头 $ 行的结尾 \\b 单词的边界 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //制定一个正则表达式规则，匹配邮箱（简单规） public static void main(String[] args) { String s = \u0026#34;122@qq.com\u0026#34;; String regex = \u0026#34;\\\\w+@\\\\w+.com\u0026#34;; //方式1 Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(s); boolean b = matcher.matches(); System.out.println(b); //方式2 boolean b1 = Pattern.matches(regex, s); System.out.println(b1); //方式3 boolean b3 = s.matches(regex); System.out.println(b3); } ","permalink":"https://train0405.github.io/posts/tech/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"\u003ch1 id=\"正则表达式\"\u003e正则表达式\u003c/h1\u003e","title":"正则表达式"},{"content":"常用API 内部类 1 2 3 4 5 6 7 1.定义：类的五大成员：属性、方法、构造器、代码块、内部类 为什么需要内部类： 类中的有一些成员，没有办法通过一个属性或者方法就能完全描述， 此时可以用一个类来充分描述 内部类的分类 成员内部类：普通的成员内部类、静态的成员内部类 局部内部类：普通的局部内部类，匿名的局部内部类 成员内部类 普通成员内部类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 内部类直接定义在类的内部，方法的外部-普通的成员内部类 使用 public class Demo { public static void main(String[] args) { A a = new A(); //B的构造器只有在A的对象里面才能找到 A.B b = a.new B(); } } class A { // 普通成员内部类 class B{} } 静态成员内部类 1 2 3 4 5 6 7 8 9 10 11 12 public class Demo { public static void main(String[] args) { C.D d = new C.D(); } } class C { //静态成员内部类 static class D{} } 局部内部类 普通局部内部类 1 2 3 4 5 1.定义 定义在类中方法的内部 2.应用场景 往往一个方法需要返回的是抽象类或者接口的对象，此时因为抽象类或者接口不能创建，于是先创建一个类来继承或者实现接口，在创建该类的对象。 把这样的类，定义在方法的内部，目的是为了节约类的加载带来的系统开销。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Demo { public static void main(String[] args) { Animal animal = getAnimal(); } public static Animal getAnimal(){ class Cat extends Animal{ @Override public void eat() { } } return new Cat();//使用了多态 Animal animal = new Cat() } } abstract class Animal{ public abstract void eat(); } 静态局部内部类 1 2 3 4 5 6 7 8 定义 匿名内部类就是内部类的简写形式，相当于是一个没有名字的子类 匿名内部类用于定义接口的或者类的子类 使用 前提是必须存在一个类，或者接口 这里的类可以是具体的类也可以是抽象类 相当于是有一个没有名字的子类继承或者实现一个类或接口，然后重写里面的方法，本质是一个继承了该类或者实现了该接口的子类匿名对象 多用于规则简单，子类使用很少的接口应用中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Demo{ public static Teacher getTeacher(){ return new Teacher(){ @Override public void teach() { System.out.println(\u0026#34;英语老师讲课\u0026#34;); } }; } } interface Teacher{ void teach(); } 权限修饰符 1 2 3 定义 权限修饰符是为了确定类或者类成员的使用范围 java中的权限修饰符\n访问级别 权限修饰符 同类 同包 子类 不同包 公开 public √ √ √ √ 受保护 protected √ √ √ 默认 （default） √ √ 私有 private √ Object 类 1 2 3 定义 所有类的基类 所有的类都是直接或者间接继承Object类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 常用方法 hashCode() public int hashCode() 返回该对象的哈希码值。默认情况下，该方法会根据对象的地址来计算。 不同对象的，hashCode()一般来说不会相同。但是，同一个对象的hashCode()值肯定相同。 toString() public String toString() 返回该对象的字符串表示 默认的方法返回的数据一般对我们没有意义, 建议重写 JavaBean中一定要去重写, 别的类中重写的概率很低 equals() 比较当前对象和指定对象是否\u0026#34;相等\u0026#34; 默认情况下比较的地址值是否相等 在我们的日常逻辑中,比较地址值是否相等没有意义, 建议重写(重写之后比较的就是类中的成员变量的值是否一样) getClass() public final Class getClass() 返回此对象的类, 可以借由字节码获取到类所有的基础结构属性 1 2 3 4 5 == 和equals()的区别 ==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值 equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性 equals()相等两个对象 hashCode()一定相同, equals不等的两个对象, hashCode()也有可能相同 建立在equals和hashCdoe同步重写的情况下 ","permalink":"https://train0405.github.io/posts/tech/%E5%B8%B8%E7%94%A8api/","summary":"\u003ch1 id=\"常用api\"\u003e常用API\u003c/h1\u003e","title":"常用api"},{"content":"常用工具类 Math 1 2 3 4 5 6 7 8 9 10 11 定义： Math类包含用于执行基本数学运算的方法, 如初等指数,对数,平方根和三角函数 常用方法 public static int abs(int a) : 返回一个数的绝对值 public static double ceil(double a) : 返回大于参数的最小整数 public static double floor(double a) : 返回小于参数的最大整数 public static int max(int a,int b) : 获取最大值 public static double pow(double a,double b) : 计算某个数的几次幂 public static double random() : 获取一个大于等于0且小于1的随机数 public static int round(float a) : 对象小数四舍五入 public static double sqrt(double a) : 计算平方根 Random 1 2 3 4 5 6 7 8 9 10 定义 此类用于产生伪随机数 之所以说是伪随机数,是因为产生的数是使用一个算法算出的 如果用相同的种子创建两个 Random 实例，则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列 构造方法 public Random() public Random(long seed) 常用方法 public int nextInt() public int nextInt(int n) : 产生一个0到参数(不包括)之内的随机整数 System 1 2 3 4 5 6 常用方法 public static void gc() : 暗示垃圾回收器运行 public static void exit(int status) : 虚拟机退出 public static long currentTimeMillis() : 获取当前时间的毫秒值 pubiic static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) : 复制数组 参数意思： 原数组 复制索引起始位置 目标数组 插入索引位置 复制长度 Date 1 2 3 4 5 6 定义 Date类表示特定的瞬间,精确到毫秒 构造方法 public Date() public Date(long date) SimpleDateFormat 1 2 3 4 5 6 7 8 定义 时间格式化工具,她以与语言无关的方式格式化并解析日期或时间 构造方法 public SimpleDateFormat() public SimpleDateFormat(String pattern) 使用一个字符串时间格式 常用方法 public final String format(Date date) 将日期格式化为字符串 public Date parse(String source) 解析文本以生成日期 时间格式标识符 字母 日期或时间元素 表示 示例 G Era 标志符 Text AD y 年 Year 1996;96 M 年中的月份 Month July;jul;07 w 年中的周数 Number 27 W 月份中的周数 Number 2 D 年中的天数 Number 189 d 月份中的天数 Number 10 F 月份中的星期 Number 8 E 星期中的天数 Text Tuesday;Tue a Am/pm 标记 Text PM H 一天中的小时数（0-23) Number 0 k 一天中的小时数（1-24） Number 24 K am/pm 中的小时数（0-11） Number 0 h am/pm 中的小时数（1-12） Number 12 m 小时中的分钟数 Number 30 s 分钟中的秒数 Number 55 S 毫秒数 Number 978 z 时区 General time zone Pacific Standard Time;PST;GMT-08:00 Z 时区 RFC 822 time zone -0800 Calendar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法 值得注意的是一周的开始是星期日,结束是星期六, 如果今天是星期一,那么instance.get(Calendar.DAY_OF_WEEK)的值就应该是2 常用字段 DAY_OF_MONTH\t表示一个月中的某天 DAY_OF_WEEK表示一个星期中的某天 DAY_OF_YEAR表示当前年中的天数 HOUR_OF_DAY表示一天中的小时 YEAR表示年份 MONTH表示月份 WEEK_OF_MONTH 表示当前月中的星期数 常用方法 public static Calendar getInstance()\t获取万年历对象 public int get(int field) 获取时间的某个值 public void add(int field,int amount) 在当前时间的基础上加上一段时间 public final void set(int year,int month,int date)设置时间点 实例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //创建实例 Calendar cal = Calendar.getInstance(); //设置时间 cal.setTime(new Date(1222133242344L)); //YEAR表示年份 int year = cal.get(Calendar.YEAR);//2008 //MONTH表示月份 月份从0开始计算 int month = cal.get(Calendar.MONTH);//9月 //DAY_OF_MONTH\t表示一个月中的某天 int day = cal.get(Calendar.DAY_OF_MONTH);//23 //HOUR_OF_DAY 表示一天中的小时 int hour = cal.get(Calendar.HOUR_OF_DAY);//9 //在当前时间的基础上加上一段时间 cal.add(Calendar.DAY_OF_MONTH,10);//Fri Oct 03 09:27:22 CST 2008 System.out.println(cal.getTime()); cal.add(Calendar.HOUR,1);//Fri Oct 03 10:27:22 CST 2008 System.out.println(cal.getTime()); ","permalink":"https://train0405.github.io/posts/tech/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/","summary":"\u003ch1 id=\"常用工具类\"\u003e常用工具类\u003c/h1\u003e","title":"常用工具类"},{"content":"面向对象二 封装 1 2 3 4 5 实现步骤 要把属性私有化，使用private进行修饰 提供公共的方法操作属性 在公共方法中加入约束逻辑 代码块 1 2 3 4 5 6 7 8 9 10 11 定义: 代码块就是定义一个无名称的代码块，用{}括起来 分类 局部代码块 : 方法中 构造代码块 : 类中方法外 静态代码块 : 类中方法外 同步代码块 : 作用域多线程中 应用 构造代码块: 创建对象时候优先于构造方法执行，多个构造方法中相同的代码放到构造代码块中，节省代码量 静态代码块: 给构造代码块加上static关键字就变成了静态代码块，用于类的初始化，在类加载的时候就执行，并且只在类加载的时候执行一次，一般用于加载驱动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Demo { //构造代码块 { System.out.println(\u0026#34;构造代码块执行了\u0026#34;); } //静态代码块 static{ System.out.println(\u0026#34;静态代码块执行了\u0026#34;); } public void method(){ //局部代码块 { System.out.println(\u0026#34;局部代码块执行了\u0026#34;); } } } 静态(static) 1 2 3 4 5 6 7 定义 用于修饰类的成员，表示静态，一旦被修饰，类的成员将不再属于这个类创建的对象。 特点 随着类的加载而加载，优先于对象存在，被类的所有对象共享，可以通过类名调用，优先于类的其他成员，类的所有静态成员都存储于静态方法区 注意事项 静态随着类的存在而存在, 随着类的消亡而消亡, jvm不关闭, 静态就一直存在, 太多的话 ,容易造成内存溢出 初始化顺序 1 2 静态成员变量 ==\u0026gt; 静态代码块 ==\u0026gt; 成员变量 ==\u0026gt; 构造代码块 ==\u0026gt; 构造方法 静态成员变量和静态代码块(构造代码块)谁写在前面谁先执行 静态和非静态 1 2 3 4 5 6 7 8 9 10 this关键字的问题 静态方法中无法使用this关键字, 因为静态方法调用的时候, 不需要对象 非静态方法中可以使用this关键字, 因为非静态方法在调用的时候必须有对象 访问成员变量 静态方法只能访问静态成员变量，如果要使用非静态的成员变量，必须先创建对象 非静态的方法可以直接访问静态的成员变量，也可以直接访问非静态的成员变量 访问成员方法 静态方法只能访问静态方法,如果想使用非静态方法就必须要创建对象 非静态方法可以直接访问静态方法,也可以直接访问非静态方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class Demo { static String name = \u0026#34;李四\u0026#34;; int age = 18; public static void method1(){ //静态方法可以直接访问静态成员方法 System.out.println(name); //这里会报错 //System.out.println(age); //静态要访问非静态的成员变量必须要创建对象 Demo demo = new Demo(); System.out.println(demo.age); //静态方法可以直接访问静态方法 method3(); //静态方法想要访问非静态方法必须要先创建对象 demo.method4(); } public void method2(){ //非静态可以直接访问静态成员变量 System.out.println(name); //非静态方法可以直接访问非静态的成员变量 System.out.println(age); //非静态方法可以直接访问静态成员方法 method3(); //非静态方法可以直接直接方法非静态方法 method4(); } //静态方法 public static void method3(){ } //非静态方法 public void method4(){ } } 继承 1 2 3 4 5 6 7 8 9 10 11 12 13 定义 从生活中的理解, 我们可以明白, 继承就是从前辈手里获取一些好处 编程语言中的继承是指让类和类之间产生关系 , 子父类关系 优缺点 优点 就是为了获取到父类中的方法和属性 提高了代码的复用性和维护性 让类和类之间产生关系,是多态的前提 缺点 类的耦合性增强了 , 我们开发的原则是高内聚,低耦合 耦合: 类与类的关系 内聚: 独立完成工作的能力 使用extends关键字让子类和父类产生联系 1 2 3 4 5 6 7 8 9 继承中的注意事项 this和super关键字 this 代表本类对象 super 代表父类对象 this.成员 调用本对象的中的成员，也可以调用父类中的成员(子类没有时) super.成员 调用父类的成员 this(...) 调用本对象的构造方法 super(...) 调用父对象的构造方法 继承中构造方法的关系 1 2 3 4 子类中的所有构造方法都会默认访问父类中的无参构造方法 因为子类继承父类中的数据 ,可能还会使用父类中的数据, 所有子类在初始化的时候, 需要将父类先初始化 每一个子类构造方法的第一条语句默认都是：super(), Object类最顶层的父类 当父类中没有空参构造的时候, 子类会报错, 这时我们可以采用调用父类的有参构造,并赋上默认值 继承中成员的关系 1 2 子类无法使用父类私有的成员 子父类中出现了一样的成员变量, 还是采用就近原则 继承中的初始化顺序 1 静态优先 父类优先 成员变量----构造代码块 ----- 构造方法 方法重写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 定义 子父类中出现了一模一样的方法 重写是一种现象, 也是一个动作 当子类需要父类的功能, 而功能主体子类有自己特有内容时, 可以重写父类的方法, 这样 , 既延续了父类的功能 , 又定义了子类特有的内容 重写的注意事项 私有方法 父类中私有方法不能被重写 父类私有方法子类可以继承，但是受到访问权限的限制，子类没有办法访问。 权限 子类重写父类方法时, 访问权限不能更低 最好保持一致 静态方法（不能被重写） 父类的静态方法, 子类也必须通过静态方法重写 重写其实是全遮挡, 调用者无法在通过任何方式去调用和子类关联的父类对象中的方法 但是静态无法做到全遮挡, 我们依然可以直接使用父类中的方法\t多态 1 2 3 4 5 6 定义 一个事物的多种形态 多态的前提 要有继承关系 要有方法重写 要有父类引用指向子类对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 演示 public class Father { public void method(){ System.out.println(\u0026#34;父类method方法\u0026#34;); } } //子类继承父类 public class Son extends Father { //重写父类的方法 public void method(){ System.out.println(\u0026#34;子类的method方法\u0026#34;); } } public static void main(String[] args) { //父类类型的变量引用子类类型的实例对象 Father father = new Son(); father.method(); } 多态成员访问的特点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 成员变量 编译看左边(父类) , 运行看左边(父类) 一般中情况使用极少, 成员变量一般都是私有化的 public class Father { String name = \u0026#34;小红\u0026#34;; } public class Son extends Father { String name = \u0026#34;小明\u0026#34;; } public static void main(String[] args) { Father father = new Son(); String str = father.name; System.out.println(str); //小红 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 成员方法 编译看左边(父类), 运行看右边(子类), 动态绑定 子类中如果对父类中的方法进行了重写, 父类中的方法无论如何都无法被访问, 这也是java动态绑定的结果 动态绑定会选择最优执行方法, 只要子类重写了父类的方法, 无论在什么地方调用, 都会先找子类 public class Father { public void method(){ System.out.println(\u0026#34;父类method方法\u0026#34;); } } public class Son extends Father { public void method(){ System.out.println(\u0026#34;子类method方法\u0026#34;); } } public static void main(String[] args) { Father father = new Son(); father.method();//子类method方法 } 1 2 静态方法 编译看左边(父类),运行看左边(父类) 多态转型 1 2 3 4 5 6 7 向上转型 将子类对象看作是父类类型, 也就是我们平时使用的多态的形式 这种情况下, 无法调用子类特有的功能 向下转型 将父类引用指向的子类对象再转回子类类型 这种转型是有危险的, 因为是强制性的, 一旦转向的类型跟这个对象不匹配, 就会报错java.lang.ClassCastException (类型转换异常, 属于运行时异常) final关键字 1 2 3 4 5 6 7 8 9 10 11 12 13 定义 final 表示最终的, 无法被修改的 final修饰的特点 修饰类, 类不能被继承 修饰变量, 变量就变成了常量, 只能被赋值一次(初始化的时候赋值 ) 修饰方法, 方法不能被重写 final 修饰局部变量 基本数据类型 , 是值不能被改变 引用数据类型, 是地址值不能被改变, 对象中的属性可以改变 final可以修饰形参 final 修饰成员变量的初始化时机 初始化完毕之前 类初始化完成前(静态) 抽象类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 定义 抽象类没有具体的代码实现, 只是规定了方法的基本属性, 然后由子类去实现具体的代码, 抽象类主要是为了定义规则而存在的 特点 抽象类和抽象方法必须用abstract 关键字修饰 abstract class 类名{} abstract 返回追类型 方法名(); 抽象类不一定有抽象方法, 有抽象方法的类一定是抽象类或者接口 抽象类不能实例化, 必须由子类继承并重写抽象方法来实例化 抽象类的子类 要么是抽象类 要么重写抽象类中的所有抽象方法(普通类) 抽象类成员方法的特点 抽象方法 , 强制要求子类做的事情 非抽象方法, 子类继承的方法, 提高代码的复用性 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 定义 接口其实就是抽象类的升级版, 接口里面都是抽象方法 从狭义上将来说, 接口就是指java 中的interface 从广义上的角度讲对外提供规则的都是接口 接口就是一套标准的规范(规则) 特点 接口用关键字interface表示 interface 接口名{ } 接口中方法上的abstract关键字可以省略 类实现接口用implements表示 class类名 implements 接口名{ } 接口不能实例化 接口按照多态的方法实例化 接口的子类 可以是抽象类, 但意义不大 可以是具体类, 要重写接口中的所有抽象方法( 主要使用 ) 接口中的成员变量必须是static final , 也就是全局常量 static , final 关键字可以省略 (建议省略) 接口可以继承接口，而且可以多继承 类 , 接口之间的关系 1 2 3 4 5 6 7 8 类与类 继承关系, 只能单继承 ,不能多继承 ,但是可以多层继承 多层继承: 子类继承父类,父类继承祖父类 类与接口 实现关系,可以单实现, 也可以多实现, 在继承类的同时,可以多实现 多个接口中出现了名称和参数列表相同的方法, 但是返回值不同, 会报错 接口与接口 继承关系 ,可以单继承, 也可以多继承 ","permalink":"https://train0405.github.io/posts/tech/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%8C/","summary":"\u003ch1 id=\"面向对象二\"\u003e面向对象二\u003c/h1\u003e","title":"面向对象二"},{"content":"面向对象的思想 定义 1 2 3 4 5 面向对象区别于面向过程而存在的, 在早期的编程语言中, 我们是先固定功能,然后根据功能来编写代码, 每一个功能对应一段代码. 这段代码只能完成本功能。 这样做的方式及其繁琐, 代码量太大, 而且检查代码会花费巨额的时间, 为了提高效率, 人们将一些可以重复使用的代码提取出来, 封装成一个方法, 这样就达到了重复使用的目的。 再后来, 我们将一些性质相近的方法放到一起, 就出现了一个类. 我们将可以完成一系列功能的类称之为对象 所谓的对象, 就是具有一定功能的独立个体。 不再局限于完成固定功能, 不在局限于代码的实现, 以创造具备某些功能的个体, 让这些个体去完成我们的指令为编程方式, 这就是面向对象的思想。 面向对象的特点 1 2 3 封装 继承 多态 类的使用 1 2 3 4 5 6 7 8 9 10 定义： 我们学习编程的目的就是为了将生活中的事和物用程序语言描述出来 如何描述 生活中的描述 属性 就是该实物的信息(事物身上的名词) 行为 就是该事物能够做什么(事物身上的动词) java中的描述 成员变量 就是事物的属性 成员方法 就是事物的行为 我们描述的是一类事物\t演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 定义学生类 属性:学号, 姓名, 年龄, 班级 , 成绩 行为:吃饭, 睡觉, 学习 public class Student { //定义学号 String num = \u0026#34;H001\u0026#34;; //定义姓名 String name = \u0026#34;小明\u0026#34;; //定义年龄 int age = 18; //定义班级 String calssnum = \u0026#34;1710\u0026#34;; //定义成绩 int score = 100; //定义吃饭方法 public void eat(){ System.out.println(\u0026#34;吃饭\u0026#34;); } //定义睡觉方法 public void sleep(){ System.out.println(\u0026#34;睡觉\u0026#34;); } //定义学习方法 public void study(){ System.out.println(\u0026#34;学java\u0026#34;); } } 注意事项 1 类是死物, 不能直接使用, 类似于图纸 对象 1 2 3 定义 在java中, 我们想要使用定义的类来做工作, 就必须先将这个类激活 激活之后的类叫做对象, 一个类可以有多个对应的对象,就像是拿图纸造出实物 1 2 3 4 格式 通过new关键字来创建对象 类名 对象名 = new 类名(); Student student = new Student(); 1 2 3 4 对象中属性值 定义类的时候, 如果类中的属性有值, 创建的对象中的属性也会是这个值 定义类的时候, 如果类中的属性没有具体值, 创建的对象中的属性会有一个默认值 一般来说, 类描述的应该是一类事物, 而不应该简简单单是一个具体的事物 对象和类的内存 1 2 3 存储位置 类存储于内存中的方法区内, 只有一份 对象存储于内存中的堆内存中, 同一个类的对象可以有多个 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) { //一个对象名引用一个实例对象 Student student = new Student(); //多个对象名引用不同的实例对象 Student student2 = new Student(); //比较两个对象表示的地址值 System.out.println(student==student2); //多个对象名引用相同的实例对象 Student student3 = student; System.out.println(student==student3); } 成员变量和局部变量 1 2 3 定义 成员变量属于类或对象, 使用对象名可以直接掉用 p1.name 局部变量属于方法, 对象无法直接调用, 只能在运行方法的时候运行 1 2 3 4 5 6 7 8 9 10 11 12 13 区别 在类中的位置不同 成员变量：在类中方法外 局部变量：定义在方法中或者方法声明上 在内存中的位置不同 成员变量：在堆内存(成员变量属于对象,对象进堆内存) 局部变量：在栈内存(局部变量属于方法,方法进栈内存) 生命周期不同 (诞生 - 活着 - 消亡) 成员变量 : 随着对象的创建而存在 , 随着对象的消亡而消亡 局部变量 : 随着方法的调用而存在 , 随着方法的结束而消亡\t初始化值不同 成员变量 : 有默认值, 是在对象创建的过程中jvm设置的默认值 局部变量 : 没有默认值, 必须在使用之前赋值\tprivate 关键字 1 2 3 4 定义 一个权限修饰符 可以修饰成员变量和成员方法 被其修饰的成员只能在本类中使用 1 2 3 作用 限定使用范围, 禁止别人调用类的成员 保证数据的安全性, 可以通过方法中的代码对有害数据进行过滤 1 2 3 4 5 JavaBean `\t类中的属性全部私有化 通过getter 和 setter方法进行设置 提供toString方法用来描述对象 javabean的主要作用是运送数据 this关键字 1 2 3 4 5 6 7 8 定义 代表本类对象的引用 用来区分成重名的成员变量和局部变量 注意事项 只能在本类方法中使用 本类的静态方法中无法使用 当我们创建对象并调用对象的方法时, 方法中如果出现了this,指的就是当前创建的这个对象 本类对象中的方法调用本类中的其他方法时, 其实被调用方法的前面就有一个省略的this 构造方法 1 2 3 定义 用于初始化对象 我们在通过new关键字创建对象的时候,必须调用构造方法 1 2 3 4 5 特点 方法名与类名相同(大小也要于类名相同) 没有返回值类型, 注意, 连void都没有 没有具体的返回值return 构造方法可以是有参的,也可以是无参的 1 2 3 4 5 6 7 8 注意事项 如果没有写构造方法, 那么编译器会自动加一个空参的构造方法 如果已经写了有参的构造方法, 编译器就不会再加上空参的构造了 这时,如果还想使用空参的构造, 那么,就需要手动补上空参构造 构造必须通过new关键字来调用, 不可以使用对象名来调用 构造方法也是成员方法, 只是比较特殊而已, 所有成员方法的属性构造方法也拥有 创建对象的时候, 只能调用一个构造方法,但构造方法内部可以相互调用 本类中的成员方法无法调用构造方法 构造方法的重载 1 2 3 定义 和成员方法的重载一样, 方法名相同,参数列表不同 需要注意的是, 只要是构造方法, 方法名一定是相同的,也就是说构造方法的重载只是参数列表不同 ","permalink":"https://train0405.github.io/posts/tech/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","summary":"\u003ch1 id=\"面向对象的思想\"\u003e面向对象的思想\u003c/h1\u003e","title":"面向对象"},{"content":"循环语句 for循环语句 格式\n1 2 3 for (初始化表达式; boolean;循环后表达式) { //执行语句 } 执行流程\n1 2 3 4 5 6 执行初始化语句 执行判断条件 , 看其返回值是true还是false 如果是true ,就执行循环体 如果是false , 就结束循环 循环体执行到最后, 执行循环后表达式 再次执行判断条件, 重复第二步 注意事项\n1 2 3 4 循环前表达式 : 在循环开始前执行, 无论循环多少次, 这个表达式只执行一次 关系表达式 : 无论是简单还是复杂 , 其结果必须是boolean 循环后表达式 : 在每次循环体执行完毕之后执行 循环体如果只有一句话, 大括号可以省略, 建议不要省略 while 循环语句 格式\n1 2 3 4 while( boolean ){ 循环语句; 控制语句; } 执行流程\n1 2 3 4 5 6 执行判断语句 , 看其返回值是true还是false 如果是true ,就继续执行 如果是false, 结束循环 执行循环体 执行控制条件语句 返回第一步继续执行 注意事项\n1 2 3 我们一般可以将while循环看作是for循环的简写格式 使用的时候一般都用在循环的次数不明确的情况下 控制条件语句也属于循环语句 do\u0026hellip;while 循环语句 格式\n1 2 3 4 do { 循环语句; 控制条件语句; } while ( boolean ); 执行流程\n1 2 3 4 5 执行循环体语句 执行控制条件语句 执行判断条件语句,看其返回值是true还是false 如果是true , 就继续执行执行循环体 如果是false, 就结束循环 注意事项\n1 do..while循环无论条件是否成立循环体都会执行一次 循环结构的总结 1 2 3 4 do....while 循环至少执行一次循环体 for , while 循环必须先判断条件是否成立,然后决定是否执行循环体语句 如果你想在循环结束后继续使用控制条件的那个变量 , 用while语句比较好 注意控制条件 , 避免造成死循环 关键字使用 break\n1 2 3 4 应用场景 在switch中使用 结束当前switch语句 在循环中使用:结束当前循环,本轮循环结束 continue\n1 跳过本次循环,继续下次循环, 这次循环中continue之后的代码都在不在执行 return\n1 2 3 可以写在方法体的任意地方 是和方法打交道的 结束整个方法, 之后的代码全部都不再执行 嵌套循环 九九乘法表\n1 2 3 4 5 6 7 for (int i = 1;i\u0026lt;=9;i++){ for (int j = 1;j\u0026lt;=i;j++){ System.out.print(j+\u0026#34;*\u0026#34;+i+\u0026#34;=\u0026#34;+i*j); System.out.print(\u0026#34; \u0026#34;); } System.out.println(); } 等腰三角形\n1 2 3 4 5 6 7 8 9 for (int i=0;i \u0026lt;5;i++){ for (int j = 0;j\u0026lt;5-i;j++){ System.out.print(\u0026#34; \u0026#34;); } for(int k = 0;k\u0026lt;2*i+1;k++){ System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } ","permalink":"https://train0405.github.io/posts/tech/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/","summary":"\u003ch1 id=\"循环语句\"\u003e循环语句\u003c/h1\u003e","title":"循环语句"},{"content":"流程控制 顺序结构 1 2 顺序结构——默认的执行序列 程序可以被控制其执行顺序。 选择结构 if结构之一 1 2 3 4 5 6 7 选择结构：根据实际情况来选择一条分支执行。 if(boolean){ //执行语句 } 先计算if关键字后面的表达式, 看其返回值是true还是false 如果是true ,就执行后面大括号中的代码 如果是false, 就不执行 if结构之二 1 2 3 4 5 6 7 8 if(boolean){ //语句体1 }else{ //语句体2 } 首先计算if后面小括号内的表达式的值, 看其返回值是true还是false 如果是true , 就执行语句体1 如果是false, 就执行语句体2 if结构之三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if(boolean){ //语句体1 }else if(boolean){ //语句体2 }else{ //语句体3 } 首先计算if 后面括号内的表达式, 看其返回值结果 如果是true就执行语句体1, if语句结束 如果是false , 就执行下一个else if后面括号中的表达式,看其结果 如果是true ,就执行语句体2 如果是false , 就接着判断下一个else if后面表达式的结果 以此类推, 直到最后执行else语句结束 如果中途有一个if或者else if 后的括号判断结果是true ,则之后的代码都不再执行 switch语句 格式\n1 2 3 4 5 6 7 8 9 10 11 12 switch(值){ case 值1:\t//语句体1; break; case 值2:\t//语句体2; break; //...... default: //语句体3; break; } 执行流程\n1 2 先看switch括号中的值 然后和case后面的值匹配, 如果有就执行这个case后面的语句, 否则执行default 控制的语句 注意事项\n1 2 3 4 case后面只能是常量, 不能是变量, 多个case后面不能出现相同的值 switch后面的值的类型只能是byte, short ,int ,字符, 字符串 , 枚举 结束条件: 执行到break , 或者代码运行完毕结束,如果一直遇不到break就会一直执行 defautl 可以省略, 但是建议不要省略 case穿透\n1 当程序执行某个case后的代码,但是没有遇到break的时候, 就会一直执行下面的所有可执行的语句 ","permalink":"https://train0405.github.io/posts/tech/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","summary":"\u003ch1 id=\"流程控制\"\u003e流程控制\u003c/h1\u003e","title":"流程控制"},{"content":"Java基础语法 关键字 1 2 定义: 被Java语言赋予了特定含义的单词 特点: 组成关键字的字母全部小写 标识符 标识符的规则\n1 2 3 4 5 6 7 8 9 1. 定义：就是给类,接口,变量等起名字时使用的字符序列 2. 组成规则 英文大小写字母 数字字符 $ 和 _ 3. 注意事项 不能以数字开头 不能是java中的关键字 区别大小写，见名知意 标识符的规范\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1. 包名 其实就是文件夹, 解决相同类名的问题 包名要求全部小写, 一般是公司的域名倒着写 www.XX.com ----\u0026gt; com.XX.包名 2. 类名 首字母大写，多个单词相连的时候，每个单词的首字母都要大写(驼峰命名)，因为多个单词连接，可能会组成新的单词，肯能会造成歧义，这是英文的书写规范 Demo TestDemo 3. 方法和变量 一个单词时，首字母小写，多个单词时，从第二个单词开始，所有的单词的首字母都要大写 get getName 4. 常量 所有字母大写，多个单词连接时，使用下划线（ _ ）连接，主要是字母全部大写之后如果没有分隔符，就很难区分单词，造成理解混乱 MAX MAX_VALUE 变量的分类 1 2 3 4 5 6 7 按照声明的位置划分:成员变量和局部变量 成员变量:定义在类的内部，方法的外部 局部变量:定义在类的方法的内部的变量 成员变量和局部变量的区别 作用域不同 初始值不同，成员变量有初始值，局部变量必须显示赋值 成员变量有访问权限修饰符，但局部变量没有，局部变量访问权限跟其所在方法权限相同 数据类型 1 2 Java中的变量具有严格的数据类型区分。（强类型语言） 在Java语言中，任何一个值，都有其对应类型的变量。 1 2 3 4 5 6 基本数据类型 整数类型 :byte short int long 浮点数类型: float double 布尔值类型:boolean 字符类型:char 1 2 3 4 引用数据类型 数组 类 接口 自增运算 1 2 a++ : 先运算，在自增 ++a :先自增，在运算 逻辑运算符 1 2 3 4 5 6 7 8 \u0026amp; 逻辑与： 只有两边都是true，逻辑运算的结果才是true,只要有一边是false，那这个结果一定是false | 逻辑或： 对于逻辑或来说，只要有一边是true，那结果就是true ^ 异或： 只有运算符两边的表达式的布尔结果不相同，才会得到true，否则一定是false ! 逻辑非：取对立面， false-\u0026gt;true true-\u0026gt;false \u0026amp;\u0026amp; 短路与：与逻辑与相同的运算逻辑，只有两边都是true，逻辑运算的结果才是true,只要有一边是false，那这个结果一定是false 在左边的表达式是false的情况下，就不会执行右边的表达式，因为这个结果一定是false || 短路或：与逻辑或的运算逻辑相同，只要有一边是true，那结果就是true.只要左边是true，那就意味着这个结果一定是true，所以右边就不执行。 如果左边是false，右边才会执行 三元运算符 1 2 3 4 三元运算符 结果 = 布尔值表达式?返回的内容1:返回的内容2 注意： 结果的数据类型 一定是和返回的内容的数据类型相同;返回的内容1和2的数据类型必须相同； 布尔值表达式如果是true则返回内容1；如果是false则返回内容2 ","permalink":"https://train0405.github.io/posts/tech/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","summary":"\u003ch1 id=\"java基础语法\"\u003eJava基础语法\u003c/h1\u003e","title":"Java基础语法"},{"content":"Java基础知识 dos常用命令操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 更换盘符:d: 查看当前目录下的文件和文件夹:dir 建立文件夹:md 文件夹名字 建立文件:echo \u0026gt; 文件名 进入文件夹:cd 文件夹名字 (change directory) 返回上一级目录:cd.. 显示文本文件:type 文件名 更改目录和文件名:REN [原名] [现名] 删除文件：del 文件名 删除文件夹：rd 文件夹名称(remove directory) /s参数 包含子目录内容一起删掉 清空屏幕：cls tab键自动补全 显示该命令的帮助信息:help 命令 第一个Java应用程序 代码注释 1 2 3 //单行注释 /**/多行注释 文档注释：（生成外部文档：javadoc -d . HelloWorld.java） 进制及进制的转换 1 2 3 4 5 6 7 8 进制，就是进位制，代表着某一位置上的运算时是逢x进一位，二进制就是逢二进一，八进制就是逢八进一，十进制就很容易理解了 现代计算机使用的是二进制，八进制，10进制，16进制 我们常用的就是二进制，10进制，和十六进制 十六进制是逢十六进一，但是咱们的数字只有1-9，所以人们用A B C D E F 来表示, 比如 45 = 2D 十进制转换成二进制 1 2 使用除积取余反序发 就是将一个十进制不停的除以2并取余数, 知道除积为0时停止, 然后将得到的余数反序就是这个十进制的二进制 二进制转换成十进制 1 从右到左用二进制的每个数去乘以2的相应次方（次方从0开始），再将其每个数进行相加。 二进制的原码、反码和补码 1 二进制有原码、反码、补码的形式 原码 1 因为有正数、负数的存在，所以计算机在存储时需要判断存入的数的符号，在计算机中，正数的符号位是0，负数的符号位是1。 ","permalink":"https://train0405.github.io/posts/tech/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"\u003ch2 id=\"java基础知识\"\u003eJava基础知识\u003c/h2\u003e","title":"java基础知识"}]