[{"content":"","permalink":"https://train0405.github.io/posts/blog/blog/","summary":"","title":"Blog"},{"content":"","permalink":"https://train0405.github.io/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://train0405.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"","permalink":"https://train0405.github.io/posts/tech/tech/","summary":"","title":"Tech"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"https://train0405.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"关于我\n英文名: Train 职业: 程序员 运动: 跑步、乒乓球、爬山 ","permalink":"https://train0405.github.io/about/","summary":"关于我 英文名: Train 职业: 程序员 运动: 跑步、乒乓球、爬山","title":"🙋🏻‍♂️关于"},{"content":"夜雨寄北\n君问归期未有期，巴山夜雨涨秋池。\n何当共剪西窗烛，却话巴山夜雨时。\n","permalink":"https://train0405.github.io/posts/life/%E8%AF%97%E6%83%85/","summary":"夜雨寄北 君问归期未有期，巴山夜雨涨秋池。 何当共剪西窗烛，却话巴山夜雨时。","title":"诗情"},{"content":" 集合 对象数组的概述和使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //需求: 创建5个学生对象, 将对象存入到数组中,遍历数组,打印学生信息 public static void main(String[] args) { Student[] sts = new Student[5]; sts[0] = new Student(\u0026#34;小红\u0026#34;, 18); sts[1] = new Student(\u0026#34;小明\u0026#34;, 19); sts[2] = new Student(\u0026#34;小白\u0026#34;, 20); sts[3] = new Student(\u0026#34;小辉\u0026#34;, 21); sts[4] = new Student(\u0026#34;小张\u0026#34;, 23); for (int i = 0; i \u0026lt; sts.length; i++) { System.out.println(sts[i]); } } //解析 //* 数组中存放的是对象的地址值 //* 遍历数组时就可以拿到引用地址值,调用对象完成方法 集合概述 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 概述 我们都知道,数组的长度是不可变的, 当元素的个数超过数组的长度之后, 我们就只能通过创建长度更长的新数组的方式来存储元素, 太麻烦了 集合给我提供另外一种容器的概念,可变长度的容器, 这样,程序在使用的时候就不需要再考虑容器容量的问题,从而可以更加专心于业务 我们要知道,java中数组是唯一的底层容器,所有, 集合是开发者使用java规范制作的逻辑上的容器 数组和集合的区别 区别1 数组既可以存储基本数据类型, 又可以储存引用数据类型,基本数据类型存储的是值, 引用数据类型储存的是地址值 集合只能存储引用数据类型(对象的引用), 其实集合也可以存储基本数据类型, 但是在存储的时候自动装箱变成包装类对象 区别2 数组长度是固定的,不能自动增长 集合的长度的是可变的,可以根据元素的增加而增长 使用场景 如果元素的个数是固定的,推荐使用数组 如果元素的个数不固定,推荐使用集合(日常开发中,使用集合比较普遍) 集合分类 Collection集合 单列集合, 直接存储对象的引用 Map集合 双列集合, 使用key-value的形式, 每个元素会有一个唯一的名称 Collection 主要关注3个子接口\nList: 有序(存入的顺序和内存中存储的顺序是相同的)，可存放重复元素\nSet: 无序，不可存放重复元素\nQueue，先进先出\nList list集合的实现类主要关注三个，如图\nArrayList 底层是数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void main(String[] args) { List list = new ArrayList\u0026lt;\u0026gt;(); //ArrayList的增删改查 list.add(\u0026#34;林黛玉\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); list.add(1,\u0026#34;史湘云\u0026#34;); System.out.println(list); List list1 = new ArrayList(); list1.add(\u0026#34;贾宝玉\u0026#34;); list1.addAll(list); System.out.println(list1); // list1.remove(\u0026#34;贾宝玉\u0026#34;); list1.remove(0); System.out.println(list1); list1.set(0,\u0026#34;刘姥姥\u0026#34;); System.out.println(list1); Object name = list1.get(0); System.out.println(name); } ArrayList的初始化\n构造器\n1 2 public ArrayList()//构造一个初始容量为10的空列表 public ArrayList(int initialCapacity)//构造具有指定初始容量的空列表 new ArrayList\u0026lt;\u0026gt;() 底层数组是否会创建，容量是多少\n1 2 3 4 5 public static void main(String[] args) { List list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); } new ArrayList的时候会调用ArrayList的空参构造方法，执行代码 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; elementData属性用于存放数据。 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 默认情况下是一个空元素数组。 也就是说this.elementData 是一个空数组。\n关注点来到list.add(1)，点进ArrayList源码查看add()，源码如下\n1 2 3 4 5 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } size：表示当前ArrayList的长度(包含元素的数量) 默认值是0。\n下面来看 ensureCapacityInternal(size + 1)；这行代码做了什么事情。\n1 2 3 4 5 6 7 8 9 10 11 12 13 //minCapacity是size+1 = 1 private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } //方法里面调用了calculateCapacity(elementData, minCapacity)这个方法翻译过来就是计算容量，第一次的话是把空数组和容量是1的参数传进来。源码进去看看 private static int calculateCapacity(Object[] elementData, int minCapacity) { //elementData是空的，DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是空，条件成立 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { //返回Math.max(DEFAULT_CAPACITY, minCapacity)之间的较大值 DEFAULT_CAPACITY默认值是10，所以返回他 return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } calculateCapacity 返回值是10，现在可以往回看ensureExplicitCapacity(10)这个方法了，看看他源码干了什么\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private void ensureExplicitCapacity(int minCapacity) { //先不管这个，并发操作的统计，防止并发失败 modCount++; // overflow-conscious code //elementData是空的数组，长度自然是0,所以条件成立 if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } //gorw方法源码 private void grow(int minCapacity) { // overflow-conscious code //oldCapacity是0 int oldCapacity = elementData.length; //oldCapacity右移1位，就是除以2，所以newCapacity也是0 int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); //条件成立 if (newCapacity - minCapacity \u0026lt; 0) //把10赋予newCapacity newCapacity = minCapacity; //MAX_ARRAY_SIZE是一个很大很大的之，条件不成立 if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //给elementData数组赋值 elementData = Arrays.copyOf(elementData, newCapacity); } 也就是说在第一次 add(1)的时候最终执行的是，这一行代码\nelementData = Arrays.copyOf(elementData, newCapacity);\n结论就是：在第一次执行add方法的时候，会给elementData赋一个容量为10的新数组，在新数组中添加元素\nIterator iterator不是一个集合，他是一个用于访问集合的方法，可以用于迭代ArrayList集合。\n迭代器 it 的两个基本操作是 next 、hasNext 和 remove。\n调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。\n调用 it.hasNext() 用于检测集合中是否还有元素。\n调用 it.remove() 将迭代器返回的元素删除。\n获取一个迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public static void main(String[] args) { List list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;林黛玉\u0026#34;); list.add(\u0026#34;史湘云\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); //获取迭代器 Iterator iterator = list.iterator(); //iterator 一开始指向前面位置 while (iterator.hasNext()) { String s = (String) iterator.next(); if (s.equals(\u0026#34;史湘云\u0026#34;)) { iterator.remove(); } else { System.out.println(s); } } } public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(7); list.add(11); list.add(12); //删除少于10的元素 Iterator\u0026lt;Integer\u0026gt; it = list.iterator(); while (it.hasNext()){ if(it.next() \u0026lt; 10){ it.remove(); } } System.out.println(list); } LinkedList 底层是双向链表，链表是一种常见的数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。\n链表可分为单向链表和双向链表。\n一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。\n一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。\nJava LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。\n与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。\n以下情况使用 ArrayList :\n​ 频繁访问列表中的某一个元素。\n​ 只需要在列表末尾进行添加和删除元素操作\n以下情况使用 LinkedList :\n​ 你需要通过循环迭代来访问列表中的某些元素。\n​ 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。\nLinkedList 继承了 AbstractSequentialList 类。\nLinkedList 实现了 Queue 接口，可作为队列使用。\nLinkedList 实现了 List 接口，可进行列表的相关操作。\nLinkedList 实现了 Deque 接口，可作为队列使用。\nLinkedList 实现了 Cloneable 接口，可实现克隆。\nLinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。\n简单的链表实例\n1 2 3 4 5 6 7 8 9 LinkedList list = new LinkedList(); list.add(\u0026#34;林黛玉\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); list.add(\u0026#34;史湘云\u0026#34;); System.out.println(list); //输出结果 [林黛玉, 薛宝钗, 薛宝钗, 史湘云] 更多的情况下我们使用 ArrayList 访问列表中的随机元素更加高效，但以下几种情况 LinkedList 提供了更高效的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static void main(String[] args) { LinkedList list = new LinkedList(); list.add(\u0026#34;林黛玉\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); list.add(\u0026#34;薛宝钗\u0026#34;); list.add(\u0026#34;史湘云\u0026#34;); //列表的开头添加元素 list.addFirst(\u0026#34;刘姥姥\u0026#34;); //在列表的结尾添加元素 list.addLast(\u0026#34;王熙凤\u0026#34;); System.out.println(list); //在列表的开头移除元素 list.removeFirst(); //在列表的结尾移除元素 list.removeLast(); System.out.println(list); //获取列表开头的元素 Object first = list.getFirst(); System.out.println(first); //获取列表结尾的元素 Object last = list.getLast(); System.out.println(last); } Vector Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：\n​ Vector 是同步访问的。\n​ Vector 包含了许多传统的方法，这些方法不属于集合框架。\nSet 无序，不重复\n不重复原因：通过hashCode方法和equals方法来保证元素的唯一性，add()返回的是boolean类型\n先判断元素的hashCode值是否一致，一致就判断equals方法，如果存储在HashSet中的两个对象hashCode方法的值相同equals方法返回的结果是true，那么HashSet认为这两个元素是相同元素，只存储一个（重复元素无法存入）。\nHashSet 和ArrayList集合都有判断元素是否相同的方法，\nboolean contains(Object o)\nHashSet使用hashCode和equals方法，ArrayList使用了equals方法\nHashSet HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。\nHashSet 允许有 null 值。\nHashSet 是无序的，即不会记录插入的顺序。\nHashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。\nHashSet 实现了 Set 接口。\nHashSet 中的元素实际上是对象，一些常见的基本类型可以使用它的包装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static void main(String[] args) { HashSet hashSet = new HashSet(); hashSet.add(\u0026#34;林黛玉\u0026#34;); hashSet.add(\u0026#34;薛宝钗\u0026#34;); hashSet.add(\u0026#34;史湘云\u0026#34;); hashSet.add(\u0026#34;王熙凤\u0026#34;); hashSet.add(\u0026#34;王熙凤\u0026#34;); System.out.println(hashSet);//[史湘云, 薛宝钗, 王熙凤, 林黛玉] // 在上面的实例中，王熙凤 被添加了两次，它在集合中也只会出现一次，因为集合中的每个元素都必须是唯一的。 //我们可以使用 contains() 方法来判断元素是否存在于集合当中: boolean b = hashSet.contains(\u0026#34;林黛玉\u0026#34;); System.out.println(b);//true // 删除元素，删除成功返回 true，否则为 false boolean b1 = hashSet.remove(\u0026#34;王熙凤\u0026#34;); System.out.println(b1);//true //iterator遍历 Iterator iterator = hashSet.iterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); } System.out.println(\u0026#34;=====\u0026#34;); //for-each 遍历 for (Object o : hashSet){ System.out.println(o); } } 使用HashSet存储自定义对象，并尝试添加重复对象（对象的重复的判定）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public static void main(String[] args) { HashSet hashSet = new HashSet(); Person person1 = new Person(12,\u0026#34;林黛玉\u0026#34;); Person person2 = new Person(13,\u0026#34;薛宝钗\u0026#34;); Person person3 = new Person(13,\u0026#34;薛宝钗\u0026#34;); hashSet.add(person1); hashSet.add(person2); hashSet.add(person3); for (Object p :hashSet){ System.out.println(p); } } } class Person{ private int age; private String name; public int getAge() { return age; } public Person(int age, String name) { this.age = age; this.name = name; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;age=\u0026#34; + age + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age \u0026amp;\u0026amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(age, name); } TreeSet TreeSet类概述\n​ 使用元素的自然顺序对元素进行排序\n​ 或者根据创建 set 时提供的 Comparator 进行排序\n​ 具体取决于使用的构造方法。\n1 2 3 4 5 构造方法 TreeSet() 构造一个新的，空的树组，根据其元素的自然排序进行排序。 TreeSet(Comparator\u0026lt;? super E\u0026gt; comparator) 构造一个新的，空的树集，根据指定的比较器进行排序。 TreeSet是如何保证元素的排序和唯一性的\n​ 底层数据结构是红黑树(红黑树是一种自平衡的二叉树)\n案例\n1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { TreeSet ts = new TreeSet(); ts.add(\u0026#34;ccc\u0026#34;); ts.add(\u0026#34;aaa\u0026#34;); ts.add(\u0026#34;ddd\u0026#34;); ts.add(\u0026#34;bbb\u0026#34;); ts.add(\u0026#34;bbb\u0026#34;); //[aaa, bbb, ccc, ddd] 不重复，自然顺序排序 System.out.println(ts); } 既然TreeSet可以自然排序,那么TreeSet必定是有排序规则的。\n1:让存入的元素自定义比较规则。\n2:给TreeSet指定排序规则。\n方式一：元素自身具备比较性\n元素自身具备比较性，需要元素实现Comparable接口，重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫做默认排序。比如String\n方式二：容器具备比较性\n当元素自身不具备比较性，或者自身具备的比较性不是所需要的。那么此时可以让容器自身具备。需要定义一个类实现接口Comparator，重写compare方法，并将该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。\n注意：当Comparable比较方式和Comparator比较方式同时存在时，以Comparator的比较方式为主；\nreturn 0来判断唯一性\n比较器接口\n1 2 3 4 ----| Comparable compareTo(Object o) 元素自身具备比较性 ----| Comparator compare( Object o1, Object o2 )\t给容器传入比较器 让元素自身具备比较性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 public class Demo10 { public static void main(String[] args) { TreeSet treeSet = new TreeSet(); treeSet.add(new Person1(15,\u0026#34;林黛玉\u0026#34;)); treeSet.add(new Person1(11,\u0026#34;薛宝钗\u0026#34;)); treeSet.add(new Person1(13,\u0026#34;史湘云\u0026#34;)); treeSet.add(new Person1(12,\u0026#34;袭人\u0026#34;)); System.out.println(treeSet); } } //让元素自身具备比较性 class Person1 implements Comparable{ public Person1(int age, String name) { this.age = age; this.name = name; } private int age; private String name; @Override public int compareTo(Object o) { Person1 p1 = (Person1)o; if(this.age \u0026gt;p1.age){ return 1; } if(this.age \u0026lt; p1.age){ return -1; } return this.name.compareTo(p1.name); } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;Person1{\u0026#34; + \u0026#34;age=\u0026#34; + age + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person1 person1 = (Person1) o; return age == person1.age \u0026amp;\u0026amp; Objects.equals(name, person1.name); } @Override public int hashCode() { return Objects.hash(age, name); } } 让容器自身具备比较性，自定义比较器\n需求：当元素自身不具备比较性，或者元素自身具备的比较性不是所需的。\n那么这时只能让容器自身具备。\n定义一个类实现Comparator 接口，覆盖compare方法。\n并将该接口的子类对象作为参数传递给TreeSet集合的构造函数。\n当Comparable比较方式，及Comparator比较方式同时存在，以Comparator\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 public class Demo13 { public static void main(String[] args) { TreeSet treeSet = new TreeSet(new MyComparator()); treeSet.add(new Computer(\u0026#34;Lenovo\u0026#34;,1000)); treeSet.add(new Computer(\u0026#34;Asus\u0026#34;,6900)); treeSet.add(new Computer(\u0026#34;MacBookPro\u0026#34;,12000)); treeSet.add(new Computer(\u0026#34;MacBookPro\u0026#34;,11000)); treeSet.add(new Computer(\u0026#34;Lenovo\u0026#34;,8900)); treeSet.add(new Computer(\u0026#34;Asus\u0026#34;,6900)); treeSet.add(new Computer(\u0026#34;MacBookPro\u0026#34;,12000)); treeSet.add(new Computer(\u0026#34;Dell\u0026#34;,7900)); System.out.println(treeSet); } } class MyComparator implements Comparator { @Override public int compare(Object o1, Object o2) { Computer computer1 = (Computer) o1; Computer computer2 = (Computer) o2; if(computer1.getName().compareTo(computer2.getName()) \u0026gt; 0){ return 1; } if(computer1.getName().compareTo(computer2.getName()) \u0026lt; 0){ return -1; } if(computer1.getPrice() \u0026gt; computer2.getPrice()){ return 1; } if(computer1.getPrice() \u0026lt; computer2.getPrice()){ return -1; } return 0; } } class Computer{ private String name; private int price; @Override public String toString() { return \u0026#34;Computer{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Computer computer = (Computer) o; return price == computer.price \u0026amp;\u0026amp; Objects.equals(name, computer.name); } @Override public int hashCode() { return Objects.hash(name, price); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public Computer(String name, int price) { this.name = name; this.price = price; } } LinkedHashSet 会保存插入的顺序。\n看到array，就要想到角标。\n看到link，就要想到first，last。\n看到hash，就要想到hashCode,equals.\n看到tree，就要想到两个接口。Comparable，Comparator。\n本文参考自\nhttps://blog.csdn.net/qq_33642117/article/details/52040345\nhttps://www.runoob.com/java/java-hashset.html\n","permalink":"https://train0405.github.io/posts/tech/list%E9%9B%86%E5%90%88/","summary":"集合 对象数组的概述和使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //需求: 创建5个学生对象, 将对象存入到数组中,遍历数组,打印学生信息 public static void main(String[] args) { Student[] sts = new Student[5]; sts[0] = new Student(\u0026#34;小红\u0026#34;, 18); sts[1] = new Student(\u0026#34;小明\u0026#34;, 19); sts[2] = new Student(\u0026#3","title":"list集合"},{"content":"正则表达式 Pattern(描述正则表达式的规则)\n1 首先将正则表达式（指定为字符串）编译为此类Pattern的实例。 然后将所得的实例可以被用来创建一个Matcher对象可以匹配任意character sequences针对正则表达式。 执行匹配的所有状态都驻留在匹配器中，所以许多匹配者可以共享相同的模式 1 2 3 4 5 6 7 // ab 正则表达式 == 规则 Pattern pattern = Pattern.compile(\u0026#34;ab\u0026#34;); //abb 待匹配的字符串 Matcher matcher = pattern.matcher(\u0026#34;abb\u0026#34;); //匹配字符是否符合正则表达式 boolean b = matcher.matches(); System.out.println(b); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1.字符内容 . 表示1个任意字符 \\d 表示1个数字，注意： 在字符串中要这么写 \\\\d \\D 表示非数字 \\s 表示1个空格 \\S 表示非空格 \\w 表示1个单词字符： a-zA-Z_0-9 \\W 表示非单词字符 a 表示字符a本身 [abc] 表示abc中的某一个 [^abc] 表示非abc中的某一个 [a-p[o-q]] 表示或 [a-p\u0026amp;\u0026amp;[o-q]] 表示与 1 2 3 4 5 6 7 8 9 10 11 12 13 2.字符数量 内容{3} 内容正好出现3次 内容{3,5} 内容出现3到5次都可以 内容{3,} 内容至少出现3次 内容? 内容出现零次或一次 内容* 内容出现零次或多次 内容+ 内容出现一次或多次 1 2 3 4 3.边界匹配器 ^ 行的开头 $ 行的结尾 \\b 单词的边界 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //制定一个正则表达式规则，匹配邮箱（简单规） public static void main(String[] args) { String s = \u0026#34;122@qq.com\u0026#34;; String regex = \u0026#34;\\\\w+@\\\\w+.com\u0026#34;; //方式1 Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(s); boolean b = matcher.matches(); System.out.println(b); //方式2 boolean b1 = Pattern.matches(regex, s); System.out.println(b1); //方式3 boolean b3 = s.matches(regex); System.out.println(b3); } ","permalink":"https://train0405.github.io/posts/tech/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"\u003ch1 id=\"正则表达式\"\u003e正则表达式\u003c/h1\u003e","title":"正则表达式"},{"content":"常用API 内部类 1 2 3 4 5 6 7 1.定义：类的五大成员：属性、方法、构造器、代码块、内部类 为什么需要内部类： 类中的有一些成员，没有办法通过一个属性或者方法就能完全描述， 此时可以用一个类来充分描述 内部类的分类 成员内部类：普通的成员内部类、静态的成员内部类 局部内部类：普通的局部内部类，匿名的局部内部类 成员内部类 普通成员内部类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 内部类直接定义在类的内部，方法的外部-普通的成员内部类 使用 public class Demo { public static void main(String[] args) { A a = new A(); //B的构造器只有在A的对象里面才能找到 A.B b = a.new B(); } } class A { // 普通成员内部类 class B{} } 静态成员内部类 1 2 3 4 5 6 7 8 9 10 11 12 public class Demo { public static void main(String[] args) { C.D d = new C.D(); } } class C { //静态成员内部类 static class D{} } 局部内部类 普通局部内部类 1 2 3 4 5 1.定义 定义在类中方法的内部 2.应用场景 往往一个方法需要返回的是抽象类或者接口的对象，此时因为抽象类或者接口不能创建，于是先创建一个类来继承或者实现接口，在创建该类的对象。 把这样的类，定义在方法的内部，目的是为了节约类的加载带来的系统开销。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Demo { public static void main(String[] args) { Animal animal = getAnimal(); } public static Animal getAnimal(){ class Cat extends Animal{ @Override public void eat() { } } return new Cat();//使用了多态 Animal animal = new Cat() } } abstract class Animal{ public abstract void eat(); } 静态局部内部类 1 2 3 4 5 6 7 8 定义 匿名内部类就是内部类的简写形式，相当于是一个没有名字的子类 匿名内部类用于定义接口的或者类的子类 使用 前提是必须存在一个类，或者接口 这里的类可以是具体的类也可以是抽象类 相当于是有一个没有名字的子类继承或者实现一个类或接口，然后重写里面的方法，本质是一个继承了该类或者实现了该接口的子类匿名对象 多用于规则简单，子类使用很少的接口应用中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Demo{ public static Teacher getTeacher(){ return new Teacher(){ @Override public void teach() { System.out.println(\u0026#34;英语老师讲课\u0026#34;); } }; } } interface Teacher{ void teach(); } 权限修饰符 1 2 3 定义 权限修饰符是为了确定类或者类成员的使用范围 java中的权限修饰符\n访问级别 权限修饰符 同类 同包 子类 不同包 公开 public √ √ √ √ 受保护 protected √ √ √ 默认 （default） √ √ 私有 private √ Object 类 1 2 3 定义 所有类的基类 所有的类都是直接或者间接继承Object类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 常用方法 hashCode() public int hashCode() 返回该对象的哈希码值。默认情况下，该方法会根据对象的地址来计算。 不同对象的，hashCode()一般来说不会相同。但是，同一个对象的hashCode()值肯定相同。 toString() public String toString() 返回该对象的字符串表示 默认的方法返回的数据一般对我们没有意义, 建议重写 JavaBean中一定要去重写, 别的类中重写的概率很低 equals() 比较当前对象和指定对象是否\u0026#34;相等\u0026#34; 默认情况下比较的地址值是否相等 在我们的日常逻辑中,比较地址值是否相等没有意义, 建议重写(重写之后比较的就是类中的成员变量的值是否一样) getClass() public final Class getClass() 返回此对象的类, 可以借由字节码获取到类所有的基础结构属性 1 2 3 4 5 == 和equals()的区别 ==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值 equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性 equals()相等两个对象 hashCode()一定相同, equals不等的两个对象, hashCode()也有可能相同 建立在equals和hashCdoe同步重写的情况下 ","permalink":"https://train0405.github.io/posts/tech/%E5%B8%B8%E7%94%A8api/","summary":"\u003ch1 id=\"常用api\"\u003e常用API\u003c/h1\u003e","title":"常用api"},{"content":"常用工具类 Math 1 2 3 4 5 6 7 8 9 10 11 定义： Math类包含用于执行基本数学运算的方法, 如初等指数,对数,平方根和三角函数 常用方法 public static int abs(int a) : 返回一个数的绝对值 public static double ceil(double a) : 返回大于参数的最小整数 public static double floor(double a) : 返回小于参数的最大整数 public static int max(int a,int b) : 获取最大值 public static double pow(double a,double b) : 计算某个数的几次幂 public static double random() : 获取一个大于等于0且小于1的随机数 public static int round(float a) : 对象小数四舍五入 public static double sqrt(double a) : 计算平方根 Random 1 2 3 4 5 6 7 8 9 10 定义 此类用于产生伪随机数 之所以说是伪随机数,是因为产生的数是使用一个算法算出的 如果用相同的种子创建两个 Random 实例，则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列 构造方法 public Random() public Random(long seed) 常用方法 public int nextInt() public int nextInt(int n) : 产生一个0到参数(不包括)之内的随机整数 System 1 2 3 4 5 6 常用方法 public static void gc() : 暗示垃圾回收器运行 public static void exit(int status) : 虚拟机退出 public static long currentTimeMillis() : 获取当前时间的毫秒值 pubiic static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) : 复制数组 参数意思： 原数组 复制索引起始位置 目标数组 插入索引位置 复制长度 Date 1 2 3 4 5 6 定义 Date类表示特定的瞬间,精确到毫秒 构造方法 public Date() public Date(long date) SimpleDateFormat 1 2 3 4 5 6 7 8 定义 时间格式化工具,她以与语言无关的方式格式化并解析日期或时间 构造方法 public SimpleDateFormat() public SimpleDateFormat(String pattern) 使用一个字符串时间格式 常用方法 public final String format(Date date) 将日期格式化为字符串 public Date parse(String source) 解析文本以生成日期 时间格式标识符 字母 日期或时间元素 表示 示例 G Era 标志符 Text AD y 年 Year 1996;96 M 年中的月份 Month July;jul;07 w 年中的周数 Number 27 W 月份中的周数 Number 2 D 年中的天数 Number 189 d 月份中的天数 Number 10 F 月份中的星期 Number 8 E 星期中的天数 Text Tuesday;Tue a Am/pm 标记 Text PM H 一天中的小时数（0-23) Number 0 k 一天中的小时数（1-24） Number 24 K am/pm 中的小时数（0-11） Number 0 h am/pm 中的小时数（1-12） Number 12 m 小时中的分钟数 Number 30 s 分钟中的秒数 Number 55 S 毫秒数 Number 978 z 时区 General time zone Pacific Standard Time;PST;GMT-08:00 Z 时区 RFC 822 time zone -0800 Calendar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法 值得注意的是一周的开始是星期日,结束是星期六, 如果今天是星期一,那么instance.get(Calendar.DAY_OF_WEEK)的值就应该是2 常用字段 DAY_OF_MONTH\t表示一个月中的某天 DAY_OF_WEEK表示一个星期中的某天 DAY_OF_YEAR表示当前年中的天数 HOUR_OF_DAY表示一天中的小时 YEAR表示年份 MONTH表示月份 WEEK_OF_MONTH 表示当前月中的星期数 常用方法 public static Calendar getInstance()\t获取万年历对象 public int get(int field) 获取时间的某个值 public void add(int field,int amount) 在当前时间的基础上加上一段时间 public final void set(int year,int month,int date)设置时间点 实例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //创建实例 Calendar cal = Calendar.getInstance(); //设置时间 cal.setTime(new Date(1222133242344L)); //YEAR表示年份 int year = cal.get(Calendar.YEAR);//2008 //MONTH表示月份 月份从0开始计算 int month = cal.get(Calendar.MONTH);//9月 //DAY_OF_MONTH\t表示一个月中的某天 int day = cal.get(Calendar.DAY_OF_MONTH);//23 //HOUR_OF_DAY 表示一天中的小时 int hour = cal.get(Calendar.HOUR_OF_DAY);//9 //在当前时间的基础上加上一段时间 cal.add(Calendar.DAY_OF_MONTH,10);//Fri Oct 03 09:27:22 CST 2008 System.out.println(cal.getTime()); cal.add(Calendar.HOUR,1);//Fri Oct 03 10:27:22 CST 2008 System.out.println(cal.getTime()); ","permalink":"https://train0405.github.io/posts/tech/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/","summary":"\u003ch1 id=\"常用工具类\"\u003e常用工具类\u003c/h1\u003e","title":"常用工具类"},{"content":"面向对象二 封装 1 2 3 4 5 实现步骤 要把属性私有化，使用private进行修饰 提供公共的方法操作属性 在公共方法中加入约束逻辑 代码块 1 2 3 4 5 6 7 8 9 10 11 定义: 代码块就是定义一个无名称的代码块，用{}括起来 分类 局部代码块 : 方法中 构造代码块 : 类中方法外 静态代码块 : 类中方法外 同步代码块 : 作用域多线程中 应用 构造代码块: 创建对象时候优先于构造方法执行，多个构造方法中相同的代码放到构造代码块中，节省代码量 静态代码块: 给构造代码块加上static关键字就变成了静态代码块，用于类的初始化，在类加载的时候就执行，并且只在类加载的时候执行一次，一般用于加载驱动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Demo { //构造代码块 { System.out.println(\u0026#34;构造代码块执行了\u0026#34;); } //静态代码块 static{ System.out.println(\u0026#34;静态代码块执行了\u0026#34;); } public void method(){ //局部代码块 { System.out.println(\u0026#34;局部代码块执行了\u0026#34;); } } } 静态(static) 1 2 3 4 5 6 7 定义 用于修饰类的成员，表示静态，一旦被修饰，类的成员将不再属于这个类创建的对象。 特点 随着类的加载而加载，优先于对象存在，被类的所有对象共享，可以通过类名调用，优先于类的其他成员，类的所有静态成员都存储于静态方法区 注意事项 静态随着类的存在而存在, 随着类的消亡而消亡, jvm不关闭, 静态就一直存在, 太多的话 ,容易造成内存溢出 初始化顺序 1 2 静态成员变量 ==\u0026gt; 静态代码块 ==\u0026gt; 成员变量 ==\u0026gt; 构造代码块 ==\u0026gt; 构造方法 静态成员变量和静态代码块(构造代码块)谁写在前面谁先执行 静态和非静态 1 2 3 4 5 6 7 8 9 10 this关键字的问题 静态方法中无法使用this关键字, 因为静态方法调用的时候, 不需要对象 非静态方法中可以使用this关键字, 因为非静态方法在调用的时候必须有对象 访问成员变量 静态方法只能访问静态成员变量，如果要使用非静态的成员变量，必须先创建对象 非静态的方法可以直接访问静态的成员变量，也可以直接访问非静态的成员变量 访问成员方法 静态方法只能访问静态方法,如果想使用非静态方法就必须要创建对象 非静态方法可以直接访问静态方法,也可以直接访问非静态方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class Demo { static String name = \u0026#34;李四\u0026#34;; int age = 18; public static void method1(){ //静态方法可以直接访问静态成员方法 System.out.println(name); //这里会报错 //System.out.println(age); //静态要访问非静态的成员变量必须要创建对象 Demo demo = new Demo(); System.out.println(demo.age); //静态方法可以直接访问静态方法 method3(); //静态方法想要访问非静态方法必须要先创建对象 demo.method4(); } public void method2(){ //非静态可以直接访问静态成员变量 System.out.println(name); //非静态方法可以直接访问非静态的成员变量 System.out.println(age); //非静态方法可以直接访问静态成员方法 method3(); //非静态方法可以直接直接方法非静态方法 method4(); } //静态方法 public static void method3(){ } //非静态方法 public void method4(){ } } 继承 1 2 3 4 5 6 7 8 9 10 11 12 13 定义 从生活中的理解, 我们可以明白, 继承就是从前辈手里获取一些好处 编程语言中的继承是指让类和类之间产生关系 , 子父类关系 优缺点 优点 就是为了获取到父类中的方法和属性 提高了代码的复用性和维护性 让类和类之间产生关系,是多态的前提 缺点 类的耦合性增强了 , 我们开发的原则是高内聚,低耦合 耦合: 类与类的关系 内聚: 独立完成工作的能力 使用extends关键字让子类和父类产生联系 1 2 3 4 5 6 7 8 9 继承中的注意事项 this和super关键字 this 代表本类对象 super 代表父类对象 this.成员 调用本对象的中的成员，也可以调用父类中的成员(子类没有时) super.成员 调用父类的成员 this(...) 调用本对象的构造方法 super(...) 调用父对象的构造方法 继承中构造方法的关系 1 2 3 4 子类中的所有构造方法都会默认访问父类中的无参构造方法 因为子类继承父类中的数据 ,可能还会使用父类中的数据, 所有子类在初始化的时候, 需要将父类先初始化 每一个子类构造方法的第一条语句默认都是：super(), Object类最顶层的父类 当父类中没有空参构造的时候, 子类会报错, 这时我们可以采用调用父类的有参构造,并赋上默认值 继承中成员的关系 1 2 子类无法使用父类私有的成员 子父类中出现了一样的成员变量, 还是采用就近原则 继承中的初始化顺序 1 静态优先 父类优先 成员变量----构造代码块 ----- 构造方法 方法重写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 定义 子父类中出现了一模一样的方法 重写是一种现象, 也是一个动作 当子类需要父类的功能, 而功能主体子类有自己特有内容时, 可以重写父类的方法, 这样 , 既延续了父类的功能 , 又定义了子类特有的内容 重写的注意事项 私有方法 父类中私有方法不能被重写 父类私有方法子类可以继承，但是受到访问权限的限制，子类没有办法访问。 权限 子类重写父类方法时, 访问权限不能更低 最好保持一致 静态方法（不能被重写） 父类的静态方法, 子类也必须通过静态方法重写 重写其实是全遮挡, 调用者无法在通过任何方式去调用和子类关联的父类对象中的方法 但是静态无法做到全遮挡, 我们依然可以直接使用父类中的方法\t多态 1 2 3 4 5 6 定义 一个事物的多种形态 多态的前提 要有继承关系 要有方法重写 要有父类引用指向子类对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 演示 public class Father { public void method(){ System.out.println(\u0026#34;父类method方法\u0026#34;); } } //子类继承父类 public class Son extends Father { //重写父类的方法 public void method(){ System.out.println(\u0026#34;子类的method方法\u0026#34;); } } public static void main(String[] args) { //父类类型的变量引用子类类型的实例对象 Father father = new Son(); father.method(); } 多态成员访问的特点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 成员变量 编译看左边(父类) , 运行看左边(父类) 一般中情况使用极少, 成员变量一般都是私有化的 public class Father { String name = \u0026#34;小红\u0026#34;; } public class Son extends Father { String name = \u0026#34;小明\u0026#34;; } public static void main(String[] args) { Father father = new Son(); String str = father.name; System.out.println(str); //小红 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 成员方法 编译看左边(父类), 运行看右边(子类), 动态绑定 子类中如果对父类中的方法进行了重写, 父类中的方法无论如何都无法被访问, 这也是java动态绑定的结果 动态绑定会选择最优执行方法, 只要子类重写了父类的方法, 无论在什么地方调用, 都会先找子类 public class Father { public void method(){ System.out.println(\u0026#34;父类method方法\u0026#34;); } } public class Son extends Father { public void method(){ System.out.println(\u0026#34;子类method方法\u0026#34;); } } public static void main(String[] args) { Father father = new Son(); father.method();//子类method方法 } 1 2 静态方法 编译看左边(父类),运行看左边(父类) 多态转型 1 2 3 4 5 6 7 向上转型 将子类对象看作是父类类型, 也就是我们平时使用的多态的形式 这种情况下, 无法调用子类特有的功能 向下转型 将父类引用指向的子类对象再转回子类类型 这种转型是有危险的, 因为是强制性的, 一旦转向的类型跟这个对象不匹配, 就会报错java.lang.ClassCastException (类型转换异常, 属于运行时异常) final关键字 1 2 3 4 5 6 7 8 9 10 11 12 13 定义 final 表示最终的, 无法被修改的 final修饰的特点 修饰类, 类不能被继承 修饰变量, 变量就变成了常量, 只能被赋值一次(初始化的时候赋值 ) 修饰方法, 方法不能被重写 final 修饰局部变量 基本数据类型 , 是值不能被改变 引用数据类型, 是地址值不能被改变, 对象中的属性可以改变 final可以修饰形参 final 修饰成员变量的初始化时机 初始化完毕之前 类初始化完成前(静态) 抽象类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 定义 抽象类没有具体的代码实现, 只是规定了方法的基本属性, 然后由子类去实现具体的代码, 抽象类主要是为了定义规则而存在的 特点 抽象类和抽象方法必须用abstract 关键字修饰 abstract class 类名{} abstract 返回追类型 方法名(); 抽象类不一定有抽象方法, 有抽象方法的类一定是抽象类或者接口 抽象类不能实例化, 必须由子类继承并重写抽象方法来实例化 抽象类的子类 要么是抽象类 要么重写抽象类中的所有抽象方法(普通类) 抽象类成员方法的特点 抽象方法 , 强制要求子类做的事情 非抽象方法, 子类继承的方法, 提高代码的复用性 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 定义 接口其实就是抽象类的升级版, 接口里面都是抽象方法 从狭义上将来说, 接口就是指java 中的interface 从广义上的角度讲对外提供规则的都是接口 接口就是一套标准的规范(规则) 特点 接口用关键字interface表示 interface 接口名{ } 接口中方法上的abstract关键字可以省略 类实现接口用implements表示 class类名 implements 接口名{ } 接口不能实例化 接口按照多态的方法实例化 接口的子类 可以是抽象类, 但意义不大 可以是具体类, 要重写接口中的所有抽象方法( 主要使用 ) 接口中的成员变量必须是static final , 也就是全局常量 static , final 关键字可以省略 (建议省略) 接口可以继承接口，而且可以多继承 类 , 接口之间的关系 1 2 3 4 5 6 7 8 类与类 继承关系, 只能单继承 ,不能多继承 ,但是可以多层继承 多层继承: 子类继承父类,父类继承祖父类 类与接口 实现关系,可以单实现, 也可以多实现, 在继承类的同时,可以多实现 多个接口中出现了名称和参数列表相同的方法, 但是返回值不同, 会报错 接口与接口 继承关系 ,可以单继承, 也可以多继承 ","permalink":"https://train0405.github.io/posts/tech/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%8C/","summary":"\u003ch1 id=\"面向对象二\"\u003e面向对象二\u003c/h1\u003e","title":"面向对象二"},{"content":"面向对象的思想 定义 1 2 3 4 5 面向对象区别于面向过程而存在的, 在早期的编程语言中, 我们是先固定功能,然后根据功能来编写代码, 每一个功能对应一段代码. 这段代码只能完成本功能。 这样做的方式及其繁琐, 代码量太大, 而且检查代码会花费巨额的时间, 为了提高效率, 人们将一些可以重复使用的代码提取出来, 封装成一个方法, 这样就达到了重复使用的目的。 再后来, 我们将一些性质相近的方法放到一起, 就出现了一个类. 我们将可以完成一系列功能的类称之为对象 所谓的对象, 就是具有一定功能的独立个体。 不再局限于完成固定功能, 不在局限于代码的实现, 以创造具备某些功能的个体, 让这些个体去完成我们的指令为编程方式, 这就是面向对象的思想。 面向对象的特点 1 2 3 封装 继承 多态 类的使用 1 2 3 4 5 6 7 8 9 10 定义： 我们学习编程的目的就是为了将生活中的事和物用程序语言描述出来 如何描述 生活中的描述 属性 就是该实物的信息(事物身上的名词) 行为 就是该事物能够做什么(事物身上的动词) java中的描述 成员变量 就是事物的属性 成员方法 就是事物的行为 我们描述的是一类事物\t演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 定义学生类 属性:学号, 姓名, 年龄, 班级 , 成绩 行为:吃饭, 睡觉, 学习 public class Student { //定义学号 String num = \u0026#34;H001\u0026#34;; //定义姓名 String name = \u0026#34;小明\u0026#34;; //定义年龄 int age = 18; //定义班级 String calssnum = \u0026#34;1710\u0026#34;; //定义成绩 int score = 100; //定义吃饭方法 public void eat(){ System.out.println(\u0026#34;吃饭\u0026#34;); } //定义睡觉方法 public void sleep(){ System.out.println(\u0026#34;睡觉\u0026#34;); } //定义学习方法 public void study(){ System.out.println(\u0026#34;学java\u0026#34;); } } 注意事项 1 类是死物, 不能直接使用, 类似于图纸 对象 1 2 3 定义 在java中, 我们想要使用定义的类来做工作, 就必须先将这个类激活 激活之后的类叫做对象, 一个类可以有多个对应的对象,就像是拿图纸造出实物 1 2 3 4 格式 通过new关键字来创建对象 类名 对象名 = new 类名(); Student student = new Student(); 1 2 3 4 对象中属性值 定义类的时候, 如果类中的属性有值, 创建的对象中的属性也会是这个值 定义类的时候, 如果类中的属性没有具体值, 创建的对象中的属性会有一个默认值 一般来说, 类描述的应该是一类事物, 而不应该简简单单是一个具体的事物 对象和类的内存 1 2 3 存储位置 类存储于内存中的方法区内, 只有一份 对象存储于内存中的堆内存中, 同一个类的对象可以有多个 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) { //一个对象名引用一个实例对象 Student student = new Student(); //多个对象名引用不同的实例对象 Student student2 = new Student(); //比较两个对象表示的地址值 System.out.println(student==student2); //多个对象名引用相同的实例对象 Student student3 = student; System.out.println(student==student3); } 成员变量和局部变量 1 2 3 定义 成员变量属于类或对象, 使用对象名可以直接掉用 p1.name 局部变量属于方法, 对象无法直接调用, 只能在运行方法的时候运行 1 2 3 4 5 6 7 8 9 10 11 12 13 区别 在类中的位置不同 成员变量：在类中方法外 局部变量：定义在方法中或者方法声明上 在内存中的位置不同 成员变量：在堆内存(成员变量属于对象,对象进堆内存) 局部变量：在栈内存(局部变量属于方法,方法进栈内存) 生命周期不同 (诞生 - 活着 - 消亡) 成员变量 : 随着对象的创建而存在 , 随着对象的消亡而消亡 局部变量 : 随着方法的调用而存在 , 随着方法的结束而消亡\t初始化值不同 成员变量 : 有默认值, 是在对象创建的过程中jvm设置的默认值 局部变量 : 没有默认值, 必须在使用之前赋值\tprivate 关键字 1 2 3 4 定义 一个权限修饰符 可以修饰成员变量和成员方法 被其修饰的成员只能在本类中使用 1 2 3 作用 限定使用范围, 禁止别人调用类的成员 保证数据的安全性, 可以通过方法中的代码对有害数据进行过滤 1 2 3 4 5 JavaBean `\t类中的属性全部私有化 通过getter 和 setter方法进行设置 提供toString方法用来描述对象 javabean的主要作用是运送数据 this关键字 1 2 3 4 5 6 7 8 定义 代表本类对象的引用 用来区分成重名的成员变量和局部变量 注意事项 只能在本类方法中使用 本类的静态方法中无法使用 当我们创建对象并调用对象的方法时, 方法中如果出现了this,指的就是当前创建的这个对象 本类对象中的方法调用本类中的其他方法时, 其实被调用方法的前面就有一个省略的this 构造方法 1 2 3 定义 用于初始化对象 我们在通过new关键字创建对象的时候,必须调用构造方法 1 2 3 4 5 特点 方法名与类名相同(大小也要于类名相同) 没有返回值类型, 注意, 连void都没有 没有具体的返回值return 构造方法可以是有参的,也可以是无参的 1 2 3 4 5 6 7 8 注意事项 如果没有写构造方法, 那么编译器会自动加一个空参的构造方法 如果已经写了有参的构造方法, 编译器就不会再加上空参的构造了 这时,如果还想使用空参的构造, 那么,就需要手动补上空参构造 构造必须通过new关键字来调用, 不可以使用对象名来调用 构造方法也是成员方法, 只是比较特殊而已, 所有成员方法的属性构造方法也拥有 创建对象的时候, 只能调用一个构造方法,但构造方法内部可以相互调用 本类中的成员方法无法调用构造方法 构造方法的重载 1 2 3 定义 和成员方法的重载一样, 方法名相同,参数列表不同 需要注意的是, 只要是构造方法, 方法名一定是相同的,也就是说构造方法的重载只是参数列表不同 ","permalink":"https://train0405.github.io/posts/tech/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","summary":"\u003ch1 id=\"面向对象的思想\"\u003e面向对象的思想\u003c/h1\u003e","title":"面向对象"},{"content":"循环语句 for循环语句 格式\n1 2 3 for (初始化表达式; boolean;循环后表达式) { //执行语句 } 执行流程\n1 2 3 4 5 6 执行初始化语句 执行判断条件 , 看其返回值是true还是false 如果是true ,就执行循环体 如果是false , 就结束循环 循环体执行到最后, 执行循环后表达式 再次执行判断条件, 重复第二步 注意事项\n1 2 3 4 循环前表达式 : 在循环开始前执行, 无论循环多少次, 这个表达式只执行一次 关系表达式 : 无论是简单还是复杂 , 其结果必须是boolean 循环后表达式 : 在每次循环体执行完毕之后执行 循环体如果只有一句话, 大括号可以省略, 建议不要省略 while 循环语句 格式\n1 2 3 4 while( boolean ){ 循环语句; 控制语句; } 执行流程\n1 2 3 4 5 6 执行判断语句 , 看其返回值是true还是false 如果是true ,就继续执行 如果是false, 结束循环 执行循环体 执行控制条件语句 返回第一步继续执行 注意事项\n1 2 3 我们一般可以将while循环看作是for循环的简写格式 使用的时候一般都用在循环的次数不明确的情况下 控制条件语句也属于循环语句 do\u0026hellip;while 循环语句 格式\n1 2 3 4 do { 循环语句; 控制条件语句; } while ( boolean ); 执行流程\n1 2 3 4 5 执行循环体语句 执行控制条件语句 执行判断条件语句,看其返回值是true还是false 如果是true , 就继续执行执行循环体 如果是false, 就结束循环 注意事项\n1 do..while循环无论条件是否成立循环体都会执行一次 循环结构的总结 1 2 3 4 do....while 循环至少执行一次循环体 for , while 循环必须先判断条件是否成立,然后决定是否执行循环体语句 如果你想在循环结束后继续使用控制条件的那个变量 , 用while语句比较好 注意控制条件 , 避免造成死循环 关键字使用 break\n1 2 3 4 应用场景 在switch中使用 结束当前switch语句 在循环中使用:结束当前循环,本轮循环结束 continue\n1 跳过本次循环,继续下次循环, 这次循环中continue之后的代码都在不在执行 return\n1 2 3 可以写在方法体的任意地方 是和方法打交道的 结束整个方法, 之后的代码全部都不再执行 嵌套循环 九九乘法表\n1 2 3 4 5 6 7 for (int i = 1;i\u0026lt;=9;i++){ for (int j = 1;j\u0026lt;=i;j++){ System.out.print(j+\u0026#34;*\u0026#34;+i+\u0026#34;=\u0026#34;+i*j); System.out.print(\u0026#34; \u0026#34;); } System.out.println(); } 等腰三角形\n1 2 3 4 5 6 7 8 9 for (int i=0;i \u0026lt;5;i++){ for (int j = 0;j\u0026lt;5-i;j++){ System.out.print(\u0026#34; \u0026#34;); } for(int k = 0;k\u0026lt;2*i+1;k++){ System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } ","permalink":"https://train0405.github.io/posts/tech/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/","summary":"\u003ch1 id=\"循环语句\"\u003e循环语句\u003c/h1\u003e","title":"循环语句"},{"content":"流程控制 顺序结构 1 2 顺序结构——默认的执行序列 程序可以被控制其执行顺序。 选择结构 if结构之一 1 2 3 4 5 6 7 选择结构：根据实际情况来选择一条分支执行。 if(boolean){ //执行语句 } 先计算if关键字后面的表达式, 看其返回值是true还是false 如果是true ,就执行后面大括号中的代码 如果是false, 就不执行 if结构之二 1 2 3 4 5 6 7 8 if(boolean){ //语句体1 }else{ //语句体2 } 首先计算if后面小括号内的表达式的值, 看其返回值是true还是false 如果是true , 就执行语句体1 如果是false, 就执行语句体2 if结构之三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if(boolean){ //语句体1 }else if(boolean){ //语句体2 }else{ //语句体3 } 首先计算if 后面括号内的表达式, 看其返回值结果 如果是true就执行语句体1, if语句结束 如果是false , 就执行下一个else if后面括号中的表达式,看其结果 如果是true ,就执行语句体2 如果是false , 就接着判断下一个else if后面表达式的结果 以此类推, 直到最后执行else语句结束 如果中途有一个if或者else if 后的括号判断结果是true ,则之后的代码都不再执行 switch语句 格式\n1 2 3 4 5 6 7 8 9 10 11 12 switch(值){ case 值1:\t//语句体1; break; case 值2:\t//语句体2; break; //...... default: //语句体3; break; } 执行流程\n1 2 先看switch括号中的值 然后和case后面的值匹配, 如果有就执行这个case后面的语句, 否则执行default 控制的语句 注意事项\n1 2 3 4 case后面只能是常量, 不能是变量, 多个case后面不能出现相同的值 switch后面的值的类型只能是byte, short ,int ,字符, 字符串 , 枚举 结束条件: 执行到break , 或者代码运行完毕结束,如果一直遇不到break就会一直执行 defautl 可以省略, 但是建议不要省略 case穿透\n1 当程序执行某个case后的代码,但是没有遇到break的时候, 就会一直执行下面的所有可执行的语句 ","permalink":"https://train0405.github.io/posts/tech/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","summary":"\u003ch1 id=\"流程控制\"\u003e流程控制\u003c/h1\u003e","title":"流程控制"},{"content":"Java基础语法 关键字 1 2 定义: 被Java语言赋予了特定含义的单词 特点: 组成关键字的字母全部小写 标识符 标识符的规则\n1 2 3 4 5 6 7 8 9 1. 定义：就是给类,接口,变量等起名字时使用的字符序列 2. 组成规则 英文大小写字母 数字字符 $ 和 _ 3. 注意事项 不能以数字开头 不能是java中的关键字 区别大小写，见名知意 标识符的规范\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1. 包名 其实就是文件夹, 解决相同类名的问题 包名要求全部小写, 一般是公司的域名倒着写 www.XX.com ----\u0026gt; com.XX.包名 2. 类名 首字母大写，多个单词相连的时候，每个单词的首字母都要大写(驼峰命名)，因为多个单词连接，可能会组成新的单词，肯能会造成歧义，这是英文的书写规范 Demo TestDemo 3. 方法和变量 一个单词时，首字母小写，多个单词时，从第二个单词开始，所有的单词的首字母都要大写 get getName 4. 常量 所有字母大写，多个单词连接时，使用下划线（ _ ）连接，主要是字母全部大写之后如果没有分隔符，就很难区分单词，造成理解混乱 MAX MAX_VALUE 变量的分类 1 2 3 4 5 6 7 按照声明的位置划分:成员变量和局部变量 成员变量:定义在类的内部，方法的外部 局部变量:定义在类的方法的内部的变量 成员变量和局部变量的区别 作用域不同 初始值不同，成员变量有初始值，局部变量必须显示赋值 成员变量有访问权限修饰符，但局部变量没有，局部变量访问权限跟其所在方法权限相同 数据类型 1 2 Java中的变量具有严格的数据类型区分。（强类型语言） 在Java语言中，任何一个值，都有其对应类型的变量。 1 2 3 4 5 6 基本数据类型 整数类型 :byte short int long 浮点数类型: float double 布尔值类型:boolean 字符类型:char 1 2 3 4 引用数据类型 数组 类 接口 自增运算 1 2 a++ : 先运算，在自增 ++a :先自增，在运算 逻辑运算符 1 2 3 4 5 6 7 8 \u0026amp; 逻辑与： 只有两边都是true，逻辑运算的结果才是true,只要有一边是false，那这个结果一定是false | 逻辑或： 对于逻辑或来说，只要有一边是true，那结果就是true ^ 异或： 只有运算符两边的表达式的布尔结果不相同，才会得到true，否则一定是false ! 逻辑非：取对立面， false-\u0026gt;true true-\u0026gt;false \u0026amp;\u0026amp; 短路与：与逻辑与相同的运算逻辑，只有两边都是true，逻辑运算的结果才是true,只要有一边是false，那这个结果一定是false 在左边的表达式是false的情况下，就不会执行右边的表达式，因为这个结果一定是false || 短路或：与逻辑或的运算逻辑相同，只要有一边是true，那结果就是true.只要左边是true，那就意味着这个结果一定是true，所以右边就不执行。 如果左边是false，右边才会执行 三元运算符 1 2 3 4 三元运算符 结果 = 布尔值表达式?返回的内容1:返回的内容2 注意： 结果的数据类型 一定是和返回的内容的数据类型相同;返回的内容1和2的数据类型必须相同； 布尔值表达式如果是true则返回内容1；如果是false则返回内容2 ","permalink":"https://train0405.github.io/posts/tech/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","summary":"\u003ch1 id=\"java基础语法\"\u003eJava基础语法\u003c/h1\u003e","title":"Java基础语法"},{"content":"Java基础知识 dos常用命令操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 更换盘符:d: 查看当前目录下的文件和文件夹:dir 建立文件夹:md 文件夹名字 建立文件:echo \u0026gt; 文件名 进入文件夹:cd 文件夹名字 (change directory) 返回上一级目录:cd.. 显示文本文件:type 文件名 更改目录和文件名:REN [原名] [现名] 删除文件：del 文件名 删除文件夹：rd 文件夹名称(remove directory) /s参数 包含子目录内容一起删掉 清空屏幕：cls tab键自动补全 显示该命令的帮助信息:help 命令 第一个Java应用程序 代码注释 1 2 3 //单行注释 /**/多行注释 文档注释：（生成外部文档：javadoc -d . HelloWorld.java） 进制及进制的转换 1 2 3 4 5 6 7 8 进制，就是进位制，代表着某一位置上的运算时是逢x进一位，二进制就是逢二进一，八进制就是逢八进一，十进制就很容易理解了 现代计算机使用的是二进制，八进制，10进制，16进制 我们常用的就是二进制，10进制，和十六进制 十六进制是逢十六进一，但是咱们的数字只有1-9，所以人们用A B C D E F 来表示, 比如 45 = 2D 十进制转换成二进制 1 2 使用除积取余反序发 就是将一个十进制不停的除以2并取余数, 知道除积为0时停止, 然后将得到的余数反序就是这个十进制的二进制 二进制转换成十进制 1 从右到左用二进制的每个数去乘以2的相应次方（次方从0开始），再将其每个数进行相加。 二进制的原码、反码和补码 1 二进制有原码、反码、补码的形式 原码 1 因为有正数、负数的存在，所以计算机在存储时需要判断存入的数的符号，在计算机中，正数的符号位是0，负数的符号位是1。 ","permalink":"https://train0405.github.io/posts/tech/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"\u003ch2 id=\"java基础知识\"\u003eJava基础知识\u003c/h2\u003e","title":"java基础知识"}]